<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Wonder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Pacifico&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: linear-gradient(135deg, #E0F7FA 0%, #B2EBF2 100%);
            --card: rgba(255, 255, 255, 0.95);
            --text: #2D3748;
            --text-secondary: #718096;
            --accent: #20B2AA; /* LightSeaGreen */
            --accent-light: #E0F2F1;
            --accent-gradient: linear-gradient(135deg, #20B2AA 0%, #48D1CC 100%);
            --cross-highlight: linear-gradient(135deg, #E6E6FA 0%, #D8BFD8 100%); /* Periwinkle Blue */
            --stuck-block: linear-gradient(135deg, #A7C7E7 0%, #B7D7F7 100%);
            --glass-primary: rgba(255, 255, 255, 0.25);
            --glass-secondary: rgba(255, 255, 255, 0.15);
            --shadow-soft: 0 6px 20px rgba(0, 0, 0, 0.12);
            --shadow-medium: 0 12px 40px rgba(0, 0, 0, 0.12);
            --shadow-strong: 0 20px 60px rgba(0, 0, 0, 0.15);
        }
        
        body {
            font-family: 'Poppins', sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow-y: auto;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        .rounded-card {
            border-radius: 16px;
            background: var(--card);
            box-shadow: var(--shadow-soft);
        }
        
        .themed-button {
            font-weight: 600;
            border-radius: 16px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            box-shadow: var(--shadow-soft);
            border: none;
            position: relative;
            overflow: hidden;
        }
        
        .themed-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.6s ease;
        }
        
        .themed-button:hover::before {
            left: 100%;
        }
        
        .themed-button:active {
            transform: scale(0.96);
        }
        
        .themed-button:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-medium);
        }
        
        .glass-card {
            background: var(--glass-secondary);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: var(--shadow-soft), 
                        0 0 0 1px rgba(255, 255, 255, 0.15),
                        inset 0 1px 0 rgba(255, 255, 255, 0.3);
            border: none !important;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .glass-card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-strong), 
                        0 0 0 1px rgba(255, 255, 255, 0.2),
                        inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }
        
        .glass-card-prominent {
            background: var(--glass-primary);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            box-shadow: var(--shadow-medium), 
                        0 0 0 1px rgba(255, 255, 255, 0.2),
                        inset 0 1px 0 rgba(255, 255, 255, 0.35);
            border: none !important;
        }
        
        .grid-cell {
            aspect-ratio: 1;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.2rem, 5.5vw, 2.75rem);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.04);
            position: relative;
            overflow: hidden;
        }
        
        .grid-cell::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.3) 0%, transparent 50%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .grid-cell:hover::before {
            opacity: 1;
        }
        
        .grid-cell:hover {
            background: rgba(178, 235, 242, 0.8);
            transform: translateY(-2px);
            box-shadow: var(--shadow-soft);
        }
        
        .themed-modal {
            border-radius: 20px;
            background: var(--card);
            box-shadow: var(--shadow-strong);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
        }
        
        @keyframes pop-in {
            0% { opacity: 0; transform: scale(0.5) rotate(-180deg); }
            50% { opacity: 1; transform: scale(1.1) rotate(-90deg); }
            100% { opacity: 1; transform: scale(1) rotate(0deg); }
        }
        
        .pop-in {
            animation: pop-in 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        @keyframes dice-tumble {
            0%   { transform: rotate(0deg) scale(1); }
            25%  { transform: rotate(-90deg) scale(1.05); }
            50%  { transform: rotate(-180deg) scale(1.1); }
            75%  { transform: rotate(-270deg) scale(1.05); }
            100% { transform: rotate(-360deg) scale(1); }
        }
        
        .dice-tumble {
            animation: dice-tumble 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(32, 178, 170, 0.4); }
            50% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(32, 178, 170, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(32, 178, 170, 0); }
        }
        
        #roll-dice-btn:not(:disabled) {
            animation: pulse 2s infinite;
        }
        
        .cross-cell {
            background: var(--cross-highlight) !important;
        }
        
        .stuck-cell {
            background: var(--stuck-block) !important;
            color: #1c3d52;
            font-size: 2rem;
            font-weight: 600;
        }

        .cursor-target {
            cursor: crosshair !important;
        }
        
        .modal {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .modal-content {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .modal.is-open {
            opacity: 1;
            visibility: visible;
        }
        
        .modal.is-open .modal-content {
            transform: scale(1) translateY(0);
        }
        
        .controls-area {
            min-height: 165px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .symbol-selector-btn {
            position: relative;
            overflow: hidden;
        }
        
        .symbol-selector-btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s ease, height 0.3s ease;
        }
        
        .symbol-selector-btn:hover::after {
            width: 100%;
            height: 100%;
        }
        
        @keyframes score-update {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); color: #5AC8FA; }
            100% { transform: scale(1); }
        }
        
        .score-update {
            animation: score-update 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        .superpower-btn {
            background: transparent;
            border: none;
            box-shadow: none;
            color: var(--accent);
            font-weight: 500;
            border-radius: 12px;
            padding: 8px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .superpower-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            text-decoration: underline;
        }

        .superpower-btn--active {
            font-weight: 700;
            transform: translateY(-2px) !important;
        }

        .superpower-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            text-decoration: none;
        }
    </style>
</head>
<body class="p-2 lg:p-4">
    <audio id="audio-unlocker" src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=" preload="auto"></audio>
    
    <main id="game-container" class="w-full max-w-5xl mx-auto flex flex-col lg:flex-row gap-4 lg:gap-6 items-center lg:items-stretch pt-8 lg:pt-16">
        <div class="w-full lg:w-2/3">
            <div id="game-board-container" class="p-2 lg:p-6 rounded-card shadow-lg h-full">
                <div class="grid grid-cols-8 gap-1 lg:gap-3 h-full">
                    <div id="game-board" class="col-span-7 grid grid-cols-7 gap-1 lg:gap-2"></div>
                    <div id="row-scores-display" class="col-span-1 grid grid-rows-7 gap-1 lg:gap-2"></div>
                    <div id="col-scores-display" class="col-span-7 grid grid-cols-7 mt-1 lg:mt-0 gap-1 lg:gap-2"></div>
                    
                    <div class="hidden lg:flex items-center justify-center">
                        <span class="text-4xl font-bold" style="font-family: 'Pacifico', cursive; color: var(--accent);">
                            WW
                        </span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="w-full lg:w-1/3">
            <div id="scoring-panel" class="flex-1 flex flex-col gap-3 lg:gap-4 p-4 lg:p-6 glass-card rounded-2xl justify-between">
                <div class="flex justify-center items-center gap-3">
                    <button id="rules-btn" class="flex-1 py-2 px-4 themed-button text-sm font-semibold" style="color: var(--accent); background: var(--accent-light);">Rules</button>
                    <button id="new-game-btn" class="flex-1 py-2 px-4 themed-button text-white font-semibold rounded-xl text-sm" style="background: var(--accent-gradient);">New Game</button>
                </div>

                <div class="w-full h-2.5 bg-teal-100 rounded-full overflow-hidden">
                    <div id="progress-bar-fill" class="h-full rounded-full transition-all duration-300" style="width: 0%; background: var(--accent-gradient);"></div>
                </div>
                
                <div id="controls-area" class="controls-area"></div>
                
                <div class="grid grid-cols-2 gap-2 lg:gap-3 text-center">
                    <div class="glass-card rounded-xl px-3 py-2">
                        <h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: #4A5568;">Total Score</h3>
                        <p id="total-score" class="text-2xl font-bold transition-all duration-300" style="color: var(--accent);">0</p>
                    </div>
                    <div class="glass-card rounded-xl px-3 py-2">
                        <h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: #4A5568;">High Score</h3>
                        <p id="high-score" class="text-2xl font-bold" style="color: #FFD700;">0</p>
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-2 lg:gap-3 text-center">
                    <div class="glass-card rounded-xl px-3 py-2"><h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: #4A5568;">Rows</h3><p id="rows-total-score" class="text-lg font-bold">0</p></div>
                    <div class="glass-card rounded-xl px-3 py-2"><h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: #4A5568;">Columns</h3><p id="cols-total-score" class="text-lg font-bold">0</p></div>
                    <div class="glass-card rounded-xl px-3 py-2"><h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: #4A5568;">Cross</h3><p id="cross-total-score" class="text-lg font-bold" style="color: #FFD700;">0</p></div>
                    <div class="glass-card rounded-xl px-3 py-2"><h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: #4A5568;">Grid Bonus</h3><p id="bonus-grid-score" class="text-lg font-bold" style="color: #FFD700;">0</p></div>
                </div>
                
                <div class="glass-card rounded-xl px-3 py-2">
                    <div class="text-center"><h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: #4A5568;">Empty Block Penalty</h3><p id="empty-block-penalty" class="text-lg font-bold" style="color: var(--accent);">0</p></div>
                </div>
            </div>
        </div>
    </main>
    
    <div id="rules-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-lg themed-modal p-6 transform scale-95 -translate-y-4">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-3xl font-bold" style="font-family: 'Pacifico', cursive; color: var(--accent);">How to Play</h2>
                <button id="close-rules-btn" class="w-10 h-10 rounded-full text-xl flex items-center justify-center font-bold">×</button>
            </div>
            <div class="space-y-4 text-gray-700 text-sm max-h-[70vh] overflow-y-auto pr-2">
                 <h3 class="font-bold text-lg" style="color: var(--accent);">The Objective</h3>
                 <p>Get the highest score by placing aquatic animals on the grid to create sequences of 3 or more identical symbols in a line (rows or columns).</p>
                 <h3 class="font-bold text-lg" style="color: var(--accent);">Gameplay</h3>
                 <ol class="list-decimal list-inside space-y-1"><li>Choose your starting aqua pet.</li><li>Click "Roll Dice" to get two new aquatic animals.</li><li>Place both animals in any two empty, adjacent (not diagonal) squares.</li></ol>
                 <h3 class="font-bold text-lg" style="color: var(--accent);">Aqua Power</h3>
                 <p>Use one of three powerful, single-use abilities per game.</p>
                 <ul class="list-disc list-inside space-y-1"><li><b>Past Lives:</b> Undoes your last completed move.</li><li><b>Bomb Splash:</b> Click to activate, then click a 💣 to replace it with a random aqua pet.</li><li><b>Exchange Please:</b> Click to activate, then click any animal on the grid to swap it.</li></ul>
                 <h3 class="font-bold text-lg" style="color: var(--accent);">Scoring</h3>
                 <ul class="list-disc list-inside space-y-1"><li><b>3 in a line:</b> 3 points</li><li><b>4 in a line:</b> 8 points</li><li><b>5 in a line:</b> 10 points</li><li><b>6 in a line:</b> 14 points</li><li><b>7 in a line:</b> 20 points</li><li><b>Cross Bonus:</b> Scores on the 4th row or 4th column are doubled!</li>
                 <li><b>Grid Bonus:</b> 2x2, 3x3, etc. grids of the same animal give bonus points (size * size).</li><li><b>Penalty:</b> A row or column that can no longer form a 3-symbol sequence gets a -5 penalty. A "dead" line on the cross gets a -10 penalty.</li></ul>
            </div>
        </div>
    </div>
    
    <div id="game-over-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-md text-center themed-modal p-8 transform scale-95 -translate-y-4 relative">
            <button id="close-game-over-btn" class="absolute top-4 right-4 w-10 h-10 rounded-full text-xl flex items-center justify-center font-bold">×</button>
            <h2 class="text-4xl font-bold mb-2" style="color: var(--accent); font-family: 'Pacifico', cursive;">Game Over!</h2>
            <p id="game-over-reason" class="text-lg mt-2 mb-4" style="color: var(--accent);"></p>
            <p id="final-score-modal" class="text-7xl font-bold my-4" style="color: var(--accent);">0</p>
            <div id="score-breakdown" class="mb-6 p-4 glass-card rounded-xl text-xs">
                <div class="grid grid-cols-2 gap-2">
                    <div class="text-left">Rows: <span id="final-rows-score" class="float-right font-bold">0</span></div>
                    <div class="text-left">Columns: <span id="final-cols-score" class="float-right font-bold">0</span></div>
                    <div class="text-left">Cross: <span id="final-cross-score" class="float-right font-bold">0</span></div>
                    <div class="text-left">Bonus Grids: <span id="final-bonus-score" class="float-right font-bold">0</span></div>
                    <div class="text-left col-span-2 border-t pt-2 mt-2">Empty Penalty: <span id="final-penalty-score" class="float-right font-bold">0</span></div>
                </div>
            </div>
            <p>High score: <span id="high-score-modal" class="font-bold" style="color: #FFD700;">0</span></p>
            <button id="play-again-btn" class="w-full mt-6 themed-button text-white font-bold py-3 px-4 rounded-xl text-xl" style="background: var(--accent-gradient);">Play Again</button>
        </div>
    </div>
    
    <div id="exchange-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-sm text-center themed-modal p-6 transform scale-95 -translate-y-4">
            <h2 class="text-xl font-bold mb-4" style="color: var(--accent);">Choose a new Aqua Pet</h2>
            <div id="exchange-options" class="grid grid-cols-3 gap-4"></div>
        </div>
    </div>

    <script>
        class GameState {
            constructor() { this.states = { PRE_GAME: 'PRE_GAME', AWAITING_ROLL: 'AWAITING_ROLL', ANIMATING_ROLL: 'ANIMATING_ROLL', AWAITING_PLACEMENT: 'AWAITING_PLACEMENT', SUPERPOWER_ACTIVE: 'SUPERPOWER_ACTIVE', PROCESSING_TURN: 'PROCESSING_TURN', GAME_OVER: 'GAME_OVER' }; this.currentState = this.states.PRE_GAME; this.validTransitions = { [this.states.PRE_GAME]: [this.states.AWAITING_ROLL], [this.states.AWAITING_ROLL]: [this.states.ANIMATING_ROLL, this.states.PRE_GAME, this.states.SUPERPOWER_ACTIVE, this.states.AWAITING_PLACEMENT], [this.states.ANIMATING_ROLL]: [this.states.AWAITING_PLACEMENT], [this.states.AWAITING_PLACEMENT]: [this.states.PROCESSING_TURN, this.states.AWAITING_ROLL, this.states.SUPERPOWER_ACTIVE], [this.states.SUPERPOWER_ACTIVE]: [this.states.AWAITING_ROLL, this.states.AWAITING_PLACEMENT, this.states.PROCESSING_TURN], [this.states.PROCESSING_TURN]: [this.states.AWAITING_ROLL, this.states.GAME_OVER], [this.states.GAME_OVER]: [this.states.PRE_GAME] }; }
            setState(newState) { if (!this.validTransitions[this.currentState]?.includes(newState)) { console.warn(`Invalid state transition from ${this.currentState} to ${newState}`); return false; } this.currentState = newState; return true; }
            is(state) { return this.currentState === state; }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const AQUA_SYMBOLS = { 'Shell': '🐚', 'Jellyfish': '🪼', 'Octopus': '🐙', 'Pufferfish': '🐡', 'Crab': '🦀', 'Whale': '🐋' };
            const SYMBOLS = Object.values(AQUA_SYMBOLS);
            const SYMBOL_COLORS = { '🐚': 'text-[#D2B48C]', '🪼': 'text-[#87CEEB]', '🐙': 'text-[#9370DB]', '🐡': 'text-[#FFD700]', '🦀': 'text-[#DC143C]', '🐋': 'text-[#4169E1]' };
            const SCORING_RULES = { 7: 20, 6: 14, 5: 10, 4: 8, 3: 3 };
            const GRID_SIZE = 7, MAX_TURNS = 24, CROSS_MULTIPLIER = 2, LINE_DEATH_PENALTY = -5, CROSS_DEATH_PENALTY = -10, STUCK_BLOCK_PENALTY = -1, MIN_SEQUENCE_LENGTH = 3;
            let gameStateManager, gridData, currentRoll, firstPlacementCell, turnCount, highScore, stuckBlocks;
            let lastGameState, hasSuperpowerBeenUsed, activeSuperpower, cellToExchange;
            let gridCells = [];
            
            const DOMElements = (() => {
                const elements = {};
                const elementIds = [
                    'game-board', 'controls-area', 'row-scores-display', 'col-scores-display', 'total-score', 
                    'high-score', 'rows-total-score', 'cols-total-score', 'cross-total-score', 'bonus-grid-score', 
                    'empty-block-penalty', 'rules-btn', 'rules-modal', 'close-rules-btn', 
                    'game-over-modal', 'game-over-reason', 'close-game-over-btn', 'final-score-modal', 
                    'high-score-modal', 'play-again-btn', 'score-breakdown', 'final-rows-score', 
                    'final-cols-score', 'final-cross-score', 'final-bonus-score', 'final-penalty-score', 
                    'exchange-modal', 'exchange-options', 'progress-bar-fill',
                    'new-game-btn', 'game-board-container', 'scoring-panel'
                ];
                elementIds.forEach(id => { elements[id] = document.getElementById(id); });
                return elements;
            })();

            const audioSystem = {
                unlocked: false, context: null, sounds: new Map(),
                init() { this.createAudioContext(); this.createSounds(); },
                createAudioContext() { try { this.context = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) {} },
                createSounds() { if (!this.context) return; const s = { 'place': [440,.1,.1], 'roll': [220,.2,.2], 'hover': [660,.05,.1], 'invalid': [150,.3,.2], 'power-activate': [880,.15,.2], 'power-use': [1047,.2,.3], 'combo-3': [[523,659],.15], 'combo-4': [[523,659,784],.2], 'combo-5': [[523,659,784,880],.25] }; for (const k in s) { if (Array.isArray(s[k][0])) this.sounds.set(k, ()=>this.playSequence(...s[k])); else this.sounds.set(k, ()=>this.playTone(...s[k])); } },
                playTone(freq, vol, dur) { if (!this.unlocked || !this.context) return; try { const o = this.context.createOscillator(), g = this.context.createGain(); o.connect(g); g.connect(this.context.destination); o.frequency.setValueAtTime(freq, this.context.currentTime); g.gain.setValueAtTime(0, this.context.currentTime); g.gain.linearRampToValueAtTime(vol*.1, this.context.currentTime+.01); g.gain.exponentialRampToValueAtTime(.001, this.context.currentTime+dur); o.start(); o.stop(this.context.currentTime+dur); } catch (e) {} },
                playSequence(freqs, dur) { freqs.forEach((f, i) => setTimeout(()=>this.playTone(f,.1,dur/freqs.length), i*(dur*1000/freqs.length))); },
                unlock() { if (this.unlocked) return; document.getElementById('audio-unlocker').play().finally(() => { this.unlocked = true; }); },
                play(soundName) { this.sounds.get(soundName)?.(); }
            };

            const scoreCalculator = {
                calculateLineScore(line, type, lineIndex) {
                    let score = 0, found = false, temp = [...line];
                    for (let len = GRID_SIZE; len >= MIN_SEQUENCE_LENGTH; len--) {
                        for (let i = 0; i <= temp.length - len; i++) {
                            const slice = temp.slice(i, i + len);
                            if (slice[0] && slice.every(s => s === slice[0])) { score += SCORING_RULES[len]; found = true; temp.fill(null, i, i + len); }
                        }
                    }
                    if (found) return { score };
                    if (this.isLineDead(line, type, lineIndex)) return { score: LINE_DEATH_PENALTY };
                    return { score: 0 };
                },
                isLineDead(line, type, lineIndex) {
                    for (let i = 0; i <= line.length - MIN_SEQUENCE_LENGTH; i++) {
                        const window = line.slice(i, i + MIN_SEQUENCE_LENGTH);
                        let winnable = true;
                        // For cross, the row/col index is always known
                        const isCrossRow = type === 'row' && lineIndex === 3;
                        const isCrossCol = type === 'col' && lineIndex === 3;

                        for (let j = 0; j < MIN_SEQUENCE_LENGTH; j++) {
                            let r, c;
                            if (type === 'row') { r = lineIndex; c = i + j; } 
                            else { r = i + j; c = lineIndex; }
                            
                            if (stuckBlocks.has(`${r},${c}`)) { winnable = false; break; }
                        }
                        if (!winnable) continue;
                        const uniqueSymbols = new Set(window.filter(cell => cell));
                        if (uniqueSymbols.size > 1) winnable = false;
                        if (winnable) return false;
                    }
                    return true;
                },
                calculateBonusGrids(gridData) {
                    let points = 0;
                    for (let size=GRID_SIZE; size>=2; size--) for (let r=0; r<=GRID_SIZE-size; r++) for (let c=0; c<=GRID_SIZE-size; c++) {
                        const s = gridData[r][c]; if (!s) continue; let isGrid = true;
                        for (let i=r; i<r+size && isGrid; i++) for (let j=c; j<c+size && isGrid; j++) if(gridData[i][j] !== s) isGrid = false;
                        if(isGrid) points += size*size;
                    }
                    return points;
                }
            };
            
            const gridManager = {
                createCellElement(r, c) { const cell = document.createElement('div'); cell.dataset.row = r; cell.dataset.col = c; cell.className = this.getCellClasses(r, c); return cell; },
                getCellClasses(r, c) { 
                    let classes = 'grid-cell bg-[#E0F2F1]'; 
                    if (r === 3 || c === 3) classes += ' cross-cell';
                    if (stuckBlocks.has(`${r},${c}`)) classes += ' stuck-cell'; 
                    return classes; 
                },
                updateCell(cell, r, c) { const symbol = gridData[r][c]; cell.className = this.getCellClasses(r, c); if (symbol) { cell.textContent = symbol; cell.classList.add(SYMBOL_COLORS[symbol], 'pop-in'); } else if (stuckBlocks.has(`${r},${c}`)) { cell.textContent = '💣'; } else { cell.textContent = ''; } },
                addCellEventListeners(cell) { cell.addEventListener('click', handleCellClick); cell.addEventListener('mouseenter', () => { if (gameStateManager.is('AWAITING_PLACEMENT') || activeSuperpower) audioSystem.play('hover'); }); }
            };

            function syncPanelHeights() {
                setTimeout(() => {
                    if (window.innerWidth < 1024) { 
                        DOMElements['scoring-panel'].style.height = 'auto';
                        return;
                    }
                    const boardHeight = DOMElements['game-board-container']?.getBoundingClientRect().height;
                    if (boardHeight && DOMElements['scoring-panel']) {
                        DOMElements['scoring-panel'].style.height = `${boardHeight}px`;
                    }
                }, 50);
            }

            function updateProgressBar() {
                if (!DOMElements['progress-bar-fill']) return;
                const percentage = (turnCount / MAX_TURNS) * 100;
                DOMElements['progress-bar-fill'].style.width = `${percentage}%`;
            }

            function initGame() {
                gameStateManager = new GameState();
                gridData = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
                currentRoll = []; firstPlacementCell = null; turnCount = 0; stuckBlocks = new Set();
                highScore = parseInt(localStorage.getItem('waterWonderHighScore')) || 0;
                hasSuperpowerBeenUsed = false; activeSuperpower = null; lastGameState = null; cellToExchange = null;
                audioSystem.init();
                DOMElements['high-score'].textContent = highScore;
                ['game-over-modal', 'exchange-modal', 'rules-modal'].forEach(id => DOMElements[id].classList.remove('is-open'));
                DOMElements['empty-block-penalty'].textContent = '0';
                renderGrid(); renderScorePlaceholders(); renderControls(); updateAllScores();
                updateProgressBar();
                syncPanelHeights();
            }

            function renderGrid() {
                const fragment = document.createDocumentFragment();
                DOMElements['game-board'].innerHTML = ''; gridCells = [];
                for (let r = 0; r < GRID_SIZE; r++) {
                    const row = [];
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const cell = gridManager.createCellElement(r, c);
                        gridManager.updateCell(cell, r, c);
                        gridManager.addCellEventListeners(cell);
                        fragment.appendChild(cell); row.push(cell);
                    }
                    gridCells.push(row);
                }
                DOMElements['game-board'].appendChild(fragment);
            }

            function updateFullGrid() { for (let r = 0; r < GRID_SIZE; r++) for (let c = 0; c < GRID_SIZE; c++) updateGridCell(r, c); }
            function updateGridCell(r, c) { if (gridCells[r]?.[c]) gridManager.updateCell(gridCells[r][c], r, c); }

            function renderScorePlaceholders() {
                DOMElements['row-scores-display'].innerHTML = ''; DOMElements['col-scores-display'].innerHTML = '';
                for (let i = 0; i < GRID_SIZE; i++) {
                    const rowScore = document.createElement('div'); rowScore.id = `row-score-${i}`; rowScore.className = 'grid-cell bg-[#E0F2F1] text-gray-400 text-lg lg:text-2xl'; rowScore.textContent = '0'; DOMElements['row-scores-display'].appendChild(rowScore);
                    const colScore = document.createElement('div'); colScore.id = `col-score-${i}`; colScore.className = 'grid-cell bg-[#E0F2F1] text-gray-400 text-lg lg:text-2xl'; colScore.textContent = '0'; DOMElements['col-scores-display'].appendChild(colScore);
                }
            }

            function renderControls() {
                DOMElements['controls-area'].innerHTML = '';
                if (gameStateManager.is('PRE_GAME')) {
                    renderPreGameControls();
                } 
                else { 
                    renderGameControls(); 
                    setupSuperpowerEventListeners();
                    updateSuperpowerButtonsUI(); 
                }
                syncPanelHeights();
            }

            function renderPreGameControls() {
                const container = document.createElement('div');
                container.className = 'w-full flex flex-col items-center';
                container.innerHTML = `<h2 class="text-base lg:text-lg font-semibold text-center mb-4 uppercase tracking-wider" style="color: var(--accent);">Choose Your Aqua Pet</h2>`;
                const selector = document.createElement('div');
                selector.className = 'grid grid-cols-3 gap-2 lg:gap-4';
                SYMBOLS.forEach((symbol) => {
                    const btn = document.createElement('button');
                    btn.className = `symbol-selector-btn aspect-square rounded-xl text-4xl lg:text-5xl hover:bg-teal-100 ${SYMBOL_COLORS[symbol]} flex items-center justify-center`;
                    btn.textContent = symbol;
                    btn.onclick = () => handleSymbolSelect(symbol);
                    btn.onmouseenter = () => audioSystem.play('hover');
                    selector.appendChild(btn);
                });
                container.appendChild(selector);
                DOMElements['controls-area'].appendChild(container);
            }

            function renderGameControls() {
                const wrapper = document.createElement('div');
                wrapper.className = 'w-full flex flex-col justify-center gap-3 lg:gap-4';
                wrapper.innerHTML = `
                    <div class="flex justify-center items-center gap-2 lg:gap-4">
                        <button id="roll-dice-btn" class="w-14 h-14 lg:w-16 lg:h-16 text-4xl lg:text-5xl flex items-center justify-center transition-transform hover:scale-110 active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed" style="color: var(--accent);">🎲</button>
                        <div id="dice-1" class="w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card shadow-lg flex items-center justify-center text-3xl lg:text-4xl">?</div>
                        <div id="dice-2" class="w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card shadow-lg flex items-center justify-center text-3xl lg:text-4xl">?</div>
                    </div>
                    <div id="aqua-power-panel" class="glass-card rounded-xl px-3 py-2 text-center">
                        <h2 class="text-sm font-semibold uppercase tracking-wider mb-2" style="color: var(--accent);">Aqua Power</h2>
                        <div class="grid grid-cols-3 gap-2 text-xs">
                            <button id="past-lives-btn" class="superpower-btn">Past Lives</button>
                            <button id="bomb-splash-btn" class="superpower-btn">Bomb Splash</button>
                            <button id="exchange-please-btn" class="superpower-btn">Exchange Please</button>
                        </div>
                    </div>
                `;
                wrapper.querySelector('#roll-dice-btn').onclick = handleRollDice;
                DOMElements['controls-area'].appendChild(wrapper);
                updateControlsState();
            }

            function updateControlsState() {
                if (gameStateManager.is('PRE_GAME')) return;
                const rollBtn = document.getElementById('roll-dice-btn');
                if (rollBtn) rollBtn.disabled = !gameStateManager.is('AWAITING_ROLL');
                const dice1 = document.getElementById('dice-1'), dice2 = document.getElementById('dice-2');
                if (!dice1 || !dice2) return;
                if (gameStateManager.is('AWAITING_PLACEMENT') && currentRoll.length === 2) {
                    dice1.textContent = currentRoll[0];
                    dice1.className = `w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card-prominent shadow-lg flex items-center justify-center text-3xl lg:text-4xl ${SYMBOL_COLORS[currentRoll[0]]}`;
                    dice2.textContent = currentRoll[1];
                    dice2.className = `w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card-prominent shadow-lg flex items-center justify-center text-3xl lg:text-4xl ${SYMBOL_COLORS[currentRoll[1]]}`;
                } else {
                    dice1.textContent = '?';
                    dice1.className = 'w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card shadow-lg flex items-center justify-center text-3xl lg:text-4xl';
                    dice2.textContent = '?';
                    dice2.className = 'w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card shadow-lg flex items-center justify-center text-3xl lg:text-4xl';
                }
            }

            function handleSymbolSelect(symbol) { if (!gameStateManager.is('PRE_GAME')) return; audioSystem.unlock(); audioSystem.play('place'); gridData[0][0] = symbol; gameStateManager.setState('AWAITING_ROLL'); updateGridCell(0, 0); renderControls(); }

            function handleRollDice() {
                if (!gameStateManager.is('AWAITING_ROLL') || gameStateManager.is('GAME_OVER')) return;
                gameStateManager.setState('ANIMATING_ROLL');
                updateControlsState();
                audioSystem.play('roll');
                const d1 = document.getElementById('dice-1'), d2 = document.getElementById('dice-2');
                d1.classList.add('dice-tumble');
                d2.classList.add('dice-tumble');
                setTimeout(() => {
                    d1.classList.remove('dice-tumble');
                    d2.classList.remove('dice-tumble');
                    currentRoll = [SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)], SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)]];
                    saveStateForUndo();
                    gameStateManager.setState('AWAITING_PLACEMENT');
                    updateControlsState();
                }, 600);
            }

            function handleCellClick(e) {
                const cell = e.target.closest('[data-row]'); if (!cell) return;
                const r = parseInt(cell.dataset.row), c = parseInt(cell.dataset.col);
                if (activeSuperpower) { handleSuperpowerCellClick(r, c); return; }
                if (!gameStateManager.is('AWAITING_PLACEMENT')) return;
                if (firstPlacementCell) { handleSecondPlacement(r, c, cell); } else { handleFirstPlacement(r, c); }
            }

            function handleFirstPlacement(r, c) { if (!gridData[r][c]) { gridData[r][c] = currentRoll[0]; firstPlacementCell = { r, c }; updateGridCell(r, c); updateSuperpowerButtonsUI(); } }
            function handleSecondPlacement(r, c, cell) {
                const { r: pR, c: pC } = firstPlacementCell;
                if (pR === r && pC === c) { gridData[r][c] = null; firstPlacementCell = null; updateGridCell(r, c); updateSuperpowerButtonsUI(); return; }
                if ((Math.abs(pR-r)+Math.abs(pC-c)===1) && !gridData[r][c]) { completeMove(r, c); } 
                else { cell.classList.add('invalid-move-shake'); setTimeout(() => cell.classList.remove('invalid-move-shake'), 400); audioSystem.play('invalid'); }
            }

            function saveStateForUndo() { lastGameState = { gridData: JSON.parse(JSON.stringify(gridData)), turnCount, stuckBlocks: new Set(stuckBlocks), currentRoll: [...currentRoll] }; }
            function completeMove(r, c) { gameStateManager.setState('PROCESSING_TURN'); gridData[r][c] = currentRoll[1]; firstPlacementCell = null; turnCount++; updateGridCell(r, c); audioSystem.play('place'); setTimeout(processTurnEnd, 300); }
            
            function processTurnEnd() {
                if (gameStateManager.is('GAME_OVER')) return;
                detectStuckBlocks(); 
                updateAllScores(); 
                updateProgressBar(); 
                if (turnCount >= MAX_TURNS) { endGame("Grid is full!"); return; } 
                if (!hasValidMoves()) { endGame("No valid moves!"); return; } 
                gameStateManager.setState('AWAITING_ROLL'); 
                renderControls(); 
            }

            function endGame(reason = "") {
                if (gameStateManager.is('GAME_OVER')) return;
                gameStateManager.setState('GAME_OVER');
                updateAllScores();
                const finalScore = calculateTotalScore();
                if (finalScore > highScore) { highScore = finalScore; localStorage.setItem('waterWonderHighScore', highScore); }
                DOMElements['game-over-reason'].textContent = reason; 
                DOMElements['final-score-modal'].textContent = finalScore; 
                DOMElements['high-score-modal'].textContent = highScore;
                DOMElements['final-rows-score'].textContent = DOMElements['rows-total-score'].textContent;
                DOMElements['final-cols-score'].textContent = DOMElements['cols-total-score'].textContent;
                DOMElements['final-cross-score'].textContent = DOMElements['cross-total-score'].textContent;
                DOMElements['final-bonus-score'].textContent = DOMElements['bonus-grid-score'].textContent;
                DOMElements['final-penalty-score'].textContent = DOMElements['empty-block-penalty'].textContent;
                setTimeout(() => DOMElements['game-over-modal'].classList.add('is-open'), 500);
            }

            function hasValidMoves() { for (let r=0; r<GRID_SIZE; r++) for (let c=0; c<GRID_SIZE; c++) if (!gridData[r][c]) { const n = [[-1,0],[1,0],[0,-1],[0,1]]; for (const [dr, dc] of n) { const nr=r+dr, nc=c+dc; if (nr>=0&&nr<GRID_SIZE&&nc>=0&&nc<GRID_SIZE&&!gridData[nr][nc]) return true; } } return false; }
            function detectStuckBlocks() { stuckBlocks.clear(); for (let r=0; r<GRID_SIZE; r++) for (let c=0; c<GRID_SIZE; c++) if (!gridData[r][c]) { const n=[[-1,0],[1,0],[0,-1],[0,1]]; if (n.every(([dr,dc])=>{const nr=r+dr,nc=c+dc; return nr<0||nr>=GRID_SIZE||nc<0||nc>=GRID_SIZE||gridData[nr][nc]})) stuckBlocks.add(`${r},${c}`); } updateFullGrid(); DOMElements['empty-block-penalty'].textContent = -stuckBlocks.size; }
            
            function updateAllScores() {
                const rS = calculateRowScores(), cS = calculateColumnScores(), crS = calculateCrossScore(), bS = scoreCalculator.calculateBonusGrids(gridData);
                updateScoreDisplays(rS.total, cS.total, crS, bS, stuckBlocks.size); updateIndividualScores(rS.individual, cS.individual);
            }
            function calculateTotalScore() { return calculateRowScores().total + calculateColumnScores().total + calculateCrossScore() + scoreCalculator.calculateBonusGrids(gridData) - stuckBlocks.size; }
            function calculateRowScores() { let t=0, ind=[]; for (let i=0; i<GRID_SIZE; i++) { if(i === 3) { ind.push(0); continue; } const {score:s} = scoreCalculator.calculateLineScore(gridData[i],'row',i); ind.push(s); t+=s; } return {total:t, individual:ind}; }
            function calculateColumnScores() { let t=0, ind=[]; for (let i=0; i<GRID_SIZE; i++) { if(i === 3) { ind.push(0); continue; } const col=gridData.map(row=>row[i]); const {score:s} = scoreCalculator.calculateLineScore(col,'col',i); ind.push(s); t+=s; } return {total:t, individual:ind}; }
            function calculateCrossScore() { 
                let totalScore = 0;
                const crossRow = gridData[3];
                const crossCol = gridData.map(row => row[3]);
                const rowResult = scoreCalculator.calculateLineScore(crossRow, 'row', 3);
                if (rowResult.score > 0) { totalScore += rowResult.score * CROSS_MULTIPLIER; } else if (rowResult.score === LINE_DEATH_PENALTY) { totalScore += CROSS_DEATH_PENALTY; }
                const colResult = scoreCalculator.calculateLineScore(crossCol, 'col', 3);
                if (colResult.score > 0) { totalScore += colResult.score * CROSS_MULTIPLIER; } else if (colResult.score === LINE_DEATH_PENALTY) { totalScore += CROSS_DEATH_PENALTY; }
                return totalScore;
            }

            function updateScoreDisplays(r,c,cross,b,s) { const t=r+c+cross+b-s; animateScoreUpdate(DOMElements['total-score'], t); animateScoreUpdate(DOMElements['rows-total-score'], r); animateScoreUpdate(DOMElements['cols-total-score'], c); animateScoreUpdate(DOMElements['cross-total-score'], cross); animateScoreUpdate(DOMElements['bonus-grid-score'], b); }
            function animateScoreUpdate(el, val) { if (parseInt(el.textContent) !== val) { el.classList.add('score-update'); el.textContent = val; setTimeout(() => el.classList.remove('score-update'), 500); } }
            function updateIndividualScores(rS, cS) { rS.forEach((s,i)=>updateScoreElement(`row-score-${i}`,s)); cS.forEach((s,i)=>updateScoreElement(`col-score-${i}`,s)); }
            function updateScoreElement(id, score) { const el=document.getElementById(id); if (el&&parseInt(el.textContent)!==score) { el.textContent=score; el.classList.toggle('text-red-500', score<0); if(score!==0) { el.classList.add('score-flash'); setTimeout(()=>el.classList.remove('score-flash'),600); } } }

            function updateSuperpowerButtonsUI() {
                const isUsed = hasSuperpowerBeenUsed;
                const isMidMove = firstPlacementCell !== null;
                const isPowerActive = activeSuperpower !== null;
                const pastLivesBtn = document.getElementById('past-lives-btn');
                const bombSplashBtn = document.getElementById('bomb-splash-btn');
                const exchangePleaseBtn = document.getElementById('exchange-please-btn');

                if(pastLivesBtn) pastLivesBtn.disabled = isUsed || !lastGameState || isMidMove || isPowerActive;
                if(bombSplashBtn) bombSplashBtn.disabled = isUsed || stuckBlocks.size === 0 || isMidMove || isPowerActive;
                if(exchangePleaseBtn) exchangePleaseBtn.disabled = isUsed || isMidMove || isPowerActive;
                
                [pastLivesBtn, bombSplashBtn, exchangePleaseBtn].forEach(btn => btn?.classList.remove('superpower-btn--active'));
                if (activeSuperpower) { 
                    const id = { 'bombSplash': 'bomb-splash-btn', 'exchangePlease': 'exchange-please-btn' }[activeSuperpower];
                    const activeBtn = document.getElementById(id);
                    if(activeBtn) activeBtn.classList.add('superpower-btn--active');
                }
                document.body.classList.toggle('cursor-target', activeSuperpower === 'bombSplash');
            }

            function handleSuperpowerCellClick(r, c) {
                if (activeSuperpower === 'bombSplash' && stuckBlocks.has(`${r},${c}`)) {
                    stuckBlocks.delete(`${r},${c}`); gridData[r][c] = SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)];
                    consumeSuperpower(); gameStateManager.setState('AWAITING_ROLL'); renderControls();
                } else if (activeSuperpower === 'exchangePlease' && gridData[r][c]) {
                    showSymbolSelectorForExchange(r, c);
                } else { audioSystem.play('invalid'); }
            }
            
            function showSymbolSelectorForExchange(r, c) {
                 cellToExchange = {r, c}; DOMElements['exchange-options'].innerHTML = '';
                 SYMBOLS.filter(s => s !== gridData[r][c]).forEach(symbol => {
                    const btn = document.createElement('button'); btn.className = 'symbol-selector-btn w-20 h-20 text-4xl rounded-lg hover:bg-teal-100 flex items-center justify-center'; btn.textContent = symbol;
                    btn.onclick = () => handleSymbolExchange(symbol); DOMElements['exchange-options'].appendChild(btn);
                 });
                 DOMElements['exchange-modal'].classList.add('is-open');
            }
            
            function handleSymbolExchange(newSymbol) {
                if (!cellToExchange) return;
                const {r, c} = cellToExchange; gridData[r][c] = newSymbol;
                DOMElements['exchange-modal'].classList.remove('is-open'); cellToExchange = null;
                consumeSuperpower(); gameStateManager.setState('AWAITING_ROLL'); renderControls();
            }

            function consumeSuperpower() { audioSystem.play('power-use'); hasSuperpowerBeenUsed = true; activeSuperpower = null; updateFullGrid(); updateAllScores(); updateSuperpowerButtonsUI(); }

            function setupSuperpowerEventListeners() {
                const pastLivesBtn = document.getElementById('past-lives-btn');
                if (pastLivesBtn) {
                    pastLivesBtn.addEventListener('click', () => {
                        if (pastLivesBtn.disabled) return;
                        audioSystem.play('power-activate');
                        gridData = lastGameState.gridData; turnCount = lastGameState.turnCount; stuckBlocks = lastGameState.stuckBlocks; currentRoll = lastGameState.currentRoll; lastGameState = null; 
                        hasSuperpowerBeenUsed = true; activeSuperpower = null; audioSystem.play('power-use');
                        updateFullGrid(); updateAllScores(); updateSuperpowerButtonsUI();
                        updateProgressBar();
                        gameStateManager.setState('AWAITING_PLACEMENT');
                        updateControlsState();
                    });
                }
                const bombSplashBtn = document.getElementById('bomb-splash-btn');
                if (bombSplashBtn) {
                    bombSplashBtn.addEventListener('click', () => {
                        if (bombSplashBtn.disabled) return;
                        activeSuperpower = 'bombSplash';
                        gameStateManager.setState('SUPERPOWER_ACTIVE'); audioSystem.play('power-activate'); updateSuperpowerButtonsUI();
                    });
                }
                const exchangePleaseBtn = document.getElementById('exchange-please-btn');
                if (exchangePleaseBtn) {
                    exchangePleaseBtn.addEventListener('click', () => {
                        if (exchangePleaseBtn.disabled) return;
                        activeSuperpower = 'exchangePlease';
                        gameStateManager.setState('SUPERPOWER_ACTIVE'); audioSystem.play('power-activate'); updateSuperpowerButtonsUI();
                    });
                }
            }

            function setupEventListeners() {
                DOMElements['new-game-btn'].addEventListener('click', initGame);
                DOMElements['rules-btn'].addEventListener('click', () => DOMElements['rules-modal'].classList.add('is-open'));
                DOMElements['close-rules-btn'].addEventListener('click', () => DOMElements['rules-modal'].classList.remove('is-open'));
                DOMElements['close-game-over-btn'].addEventListener('click', () => DOMElements['game-over-modal'].classList.remove('is-open'));
                DOMElements['play-again-btn'].addEventListener('click', () => { DOMElements['game-over-modal'].classList.remove('is-open'); setTimeout(initGame, 200); });
                
                window.addEventListener('resize', syncPanelHeights);

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        if (activeSuperpower) { activeSuperpower = null; updateSuperpowerButtonsUI(); gameStateManager.setState(firstPlacementCell ? 'AWAITING_PLACEMENT' : 'AWAITING_ROLL'); } 
                        else { ['rules-modal', 'game-over-modal', 'exchange-modal'].forEach(id => DOMElements[id].classList.remove('is-open')); }
                    }
                    if ((e.key === ' ' || e.key === 'Enter') && gameStateManager.is('AWAITING_ROLL')) { e.preventDefault(); handleRollDice(); }
                });
            };

            initGame();
            setupEventListeners();
        });
    </script>
</body>
</html>
