<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALLOHA</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Pacifico&display=swap" rel="stylesheet">
    
    <style>
        :root {
            /* Enhanced background with more depth */
            --bg: linear-gradient(135deg, #E0F7FA 0%, #B2EBF2 50%, #80DEEA 100%);
            --card: rgba(255, 255, 255, 0.95);
            --text: #2D3748;
            --text-secondary: #718096;
            --accent: #20B2AA; /* LightSeaGreen */
            --accent-light: #E0F2F1;
            /* Enhanced gradients with more stops */
            --accent-gradient: linear-gradient(135deg, #20B2AA 0%, #48D1CC 50%, #40E0D0 100%);
            --cross-highlight: linear-gradient(135deg, #E6E6FA 0%, #D8BFD8 100%); /* Periwinkle Blue */
            --stuck-block: linear-gradient(135deg, #A7C7E7 0%, #B7D7F7 100%);
            
            /* Enhanced glass effects */
            --glass-primary: rgba(255, 255, 255, 0.3);
            --glass-secondary: rgba(255, 255, 255, 0.18);
            --glass-border: rgba(255, 255, 255, 0.2);
            
            /* Progressive shadow system */
            --shadow-minimal: 0 2px 8px rgba(0, 0, 0, 0.06);
            --shadow-soft: 0 6px 20px rgba(0, 0, 0, 0.08);
            --shadow-medium: 0 12px 40px rgba(0, 0, 0, 0.10);
            --shadow-strong: 0 20px 60px rgba(0, 0, 0, 0.12);
            --shadow-dramatic: 0 30px 80px rgba(0, 0, 0, 0.15);
            
            /* Animation curves */
            --ease-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
            --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
            --ease-quick: cubic-bezier(0.25, 0.8, 0.25, 1);
            
            /* New shimmer effects */
            --shimmer-gradient: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.4) 50%, transparent 100%);
            --progress-shimmer: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.6) 50%, transparent 100%);
        }

        /* Accessibility: Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
            
            .themed-button::before,
            .progress-bar-fill::after {
                display: none;
            }
        }

        /* Accessibility: High contrast mode */
        @media (prefers-contrast: high) {
            :root {
                --shadow-soft: 0 6px 20px rgba(0, 0, 0, 0.25);
                --shadow-medium: 0 12px 40px rgba(0, 0, 0, 0.30);
                --glass-primary: rgba(255, 255, 255, 0.5);
                --glass-secondary: rgba(255, 255, 255, 0.3);
            }
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow-x: hidden; /* Prevent horizontal scroll */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #bubbles-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
        }

        .bubble {
            position: absolute;
            bottom: -50px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            animation: floatUp 10s infinite;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0) translateX(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-120vh) translateX(20px);
                opacity: 0;
            }
        }

        .rounded-card {
            border-radius: 16px;
            background: var(--card);
            box-shadow: var(--shadow-soft);
        }

        .themed-button {
            font-weight: 600;
            border-radius: 16px;
            transition: all 0.3s var(--ease-smooth);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            box-shadow: var(--shadow-soft);
            border: none;
            position: relative;
            overflow: hidden;
            transform-origin: center;
        }
        
        .themed-button:active {
            transform: scale(0.98);
            transition-duration: 0.1s;
        }
        
        .themed-button:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: var(--shadow-medium);
        }

        .glass-card {
            background: linear-gradient(135deg, var(--glass-secondary) 0%, rgba(255,255,255,0.1) 100%);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            box-shadow: var(--shadow-soft), 
                        0 0 0 1px var(--glass-border),
                        inset 0 1px 0 rgba(255, 255, 255, 0.3);
            border: none !important;
            transition: all 0.3s var(--ease-smooth);
            position: relative;
            overflow: hidden;
        }

        .glass-card:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-medium), 
                        0 0 0 1px rgba(255, 255, 255, 0.25),
                        inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }

        .glass-card > * {
            position: relative;
            z-index: 1;
        }

        .glass-card-prominent {
            background: linear-gradient(135deg, var(--glass-primary) 0%, rgba(255,255,255,0.2) 100%);
            backdrop-filter: blur(25px) saturate(200%);
            -webkit-backdrop-filter: blur(25px) saturate(200%);
            box-shadow: var(--shadow-medium), 
                        0 0 0 1px rgba(255, 255, 255, 0.25),
                        inset 0 1px 0 rgba(255, 255, 255, 0.4),
                        0 0 40px rgba(32, 178, 170, 0.1);
            border: none !important;
        }

        .grid-cell {
            aspect-ratio: 1;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.2rem, 5.5vw, 2.75rem);
            transition: all 0.3s var(--ease-smooth);
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.04);
            position: relative;
            overflow: hidden;
        }
        
        .grid-cell:hover {
            background: rgba(178, 235, 242, 0.8);
            transform: translateY(-2px);
            box-shadow: var(--shadow-soft);
        }

        .themed-modal {
            border-radius: 20px;
            background: var(--card);
            box-shadow: var(--shadow-strong);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
        }

        .progress-bar-container {
            position: relative;
            overflow: hidden;
            background: rgba(178, 235, 242, 0.3);
            border-radius: 9999px;
        }

        .progress-bar-fill {
            background: var(--accent-gradient);
            position: relative;
            overflow: hidden;
            transition: width 0.3s var(--ease-smooth);
        }

        @keyframes pop-in {
            0% { opacity: 0; transform: scale(0.5) rotate(-180deg); }
            50% { opacity: 1; transform: scale(1.1) rotate(-90deg); }
            100% { opacity: 1; transform: scale(1) rotate(0deg); }
        }

        .pop-in {
            animation: pop-in 0.4s var(--ease-bounce);
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px) rotate(-3deg); }
            75% { transform: translateX(5px) rotate(3deg); }
        }

        .shake-animation {
            animation: shake 0.4s ease-in-out;
        }

        @keyframes dice-tumble {
            0%   { transform: rotate(0deg) scale(1); filter: blur(0px); }
            25%  { transform: rotate(-90deg) scale(1.05); }
            50%  { transform: rotate(-180deg) scale(1.1); filter: blur(3px); }
            75%  { transform: rotate(-270deg) scale(1.05); }
            100% { transform: rotate(-360deg) scale(1); filter: blur(0px); }
        }

        .dice-tumble {
            animation: dice-tumble 0.6s var(--ease-bounce);
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(32, 178, 170, 0.4); }
            50% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(32, 178, 170, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(32, 178, 170, 0); }
        }

        #roll-dice-btn:not(:disabled) {
            animation: pulse 2s infinite;
        }

        .cross-cell {
            background: var(--cross-highlight) !important;
        }

        .stuck-cell {
            background: var(--stuck-block) !important;
            color: #1c3d52;
            font-size: 2rem;
            font-weight: 600;
        }

        .cursor-target {
            cursor: crosshair !important;
        }

        .modal { transition: all 0.3s var(--ease-smooth); }
        .modal-content { transition: all 0.3s var(--ease-smooth); }
        .modal.is-open { opacity: 1; visibility: visible; }
        .modal.is-open .modal-content { transform: scale(1) translateY(0); }

        .controls-area {
            min-height: 165px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes score-update {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); color: #5AC8FA; }
            100% { transform: scale(1); }
        }

        .score-update {
            animation: score-update 0.5s var(--ease-quick);
        }

        .superpower-btn {
            background: transparent;
            border: none;
            box-shadow: none;
            color: var(--accent);
            font-weight: 500;
            border-radius: 12px;
            padding: 8px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .superpower-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            text-decoration: underline;
        }

        .superpower-btn--active {
            font-weight: 700;
            transform: translateY(-2px) !important;
        }

        .superpower-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            text-decoration: none;
        }

        .alloha-logo {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .alloha-logo svg {
            width: 100%;
            height: 100%;
        }

        /* --- NEW: Mobile Touch Interaction Styles --- */
        .valid-move-highlight {
            background-color: rgba(32, 178, 170, 0.3) !important;
            box-shadow: 0 0 0 3px rgba(32, 178, 170, 0.5);
            animation: pulse-highlight 1.5s infinite;
            cursor: pointer;
        }

        @keyframes pulse-highlight {
            0% { box-shadow: 0 0 0 0 rgba(32, 178, 170, 0.5); }
            70% { box-shadow: 0 0 0 10px rgba(32, 178, 170, 0); }
            100% { box-shadow: 0 0 0 0 rgba(32, 178, 170, 0); }
        }

        /* --- NEW: Mobile Responsive Styles --- */
        @media (max-width: 1023px) {
            body {
                padding: 0.5rem;
            }
            main#game-container {
                padding-top: 1rem;
            }
            #game-board-container {
                padding: 0.5rem;
            }
            #game-board, #row-scores-display, #col-scores-display {
                gap: 0.5rem;
            }
        }

    </style>
</head>
<body class="p-2 lg:p-4">
    <div id="bubbles-bg"></div>
    <audio id="audio-unlocker" src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=" preload="auto"></audio>
    
    <main id="game-container" class="w-full max-w-5xl mx-auto flex flex-col lg:flex-row gap-4 lg:gap-6 items-center lg:items-stretch pt-8 lg:pt-16">
        <div class="w-full lg:w-2/3 relative">
            <div id="effects-container" class="absolute inset-0 pointer-events-none z-10 overflow-hidden"></div>
            <div id="game-board-container" class="p-2 lg:p-6 rounded-card shadow-lg h-full">
                <div class="grid grid-cols-8 gap-1 lg:gap-3 h-full">
                    <div id="game-board" class="col-span-7 grid grid-cols-7 gap-1 lg:gap-2"></div>
                    <div id="row-scores-display" class="col-span-1 grid grid-rows-7 gap-1 lg:gap-2"></div>
                    <div id="col-scores-display" class="col-span-7 grid grid-cols-7 mt-1 lg:mt-0 gap-1 lg:gap-2"></div>
                    
                    <div class="hidden lg:flex items-center justify-center">
                        <div class="alloha-logo">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 396.75 396.749985" preserveAspectRatio="xMidYMid meet" version="1.0"><defs><clipPath id="864cd2432c"><path d="M 40 0 L 355 0 L 355 396.5 L 40 396.5 Z M 40 0 " clip-rule="nonzero"/></clipPath><clipPath id="9e91a8b430"><rect x="0" width="169" y="0" height="269"/></clipPath><clipPath id="9a4060e8fa"><path d="M 146 116 L 314.976562 116 L 314.976562 396.5 L 146 396.5 Z M 146 116 " clip-rule="nonzero"/></clipPath><clipPath id="f5a1301079"><rect x="0" width="169" y="0" height="281"/></clipPath><clipPath id="45fb35c46f"><rect x="0" width="166" y="0" height="269"/></clipPath><clipPath id="cd05768fb1"><path d="M 0.292969 116 L 171 116 L 171 396.5 L 0.292969 396.5 Z M 0.292969 116 " clip-rule="nonzero"/></clipPath><clipPath id="f5e8ebd13e"><rect x="0" width="171" y="0" height="281"/></clipPath><clipPath id="22bb000506"><path d="M 242.375 20.429688 L 285.164062 20.429688 L 285.164062 140.25 L 242.375 140.25 Z M 242.375 20.429688 " clip-rule="nonzero"/></clipPath><clipPath id="cb13c63ddb"><path d="M 0.375 0.429688 L 43.164062 0.429688 L 43.164062 120.25 L 0.375 120.25 Z M 0.375 0.429688 " clip-rule="nonzero"/></clipPath><clipPath id="7703948ec8"><rect x="0" width="44" y="0" height="121"/></clipPath><clipPath id="0f7bc66451"><path d="M 213.839844 20.4375 L 276.609375 20.4375 L 276.609375 63.222656 L 213.839844 63.222656 Z M 213.839844 20.4375 " clip-rule="nonzero"/></clipPath><clipPath id="90aa4af11e"><path d="M 0.839844 0.4375 L 63.609375 0.4375 L 63.609375 43.222656 L 0.839844 43.222656 Z M 0.839844 0.4375 " clip-rule="nonzero"/></clipPath><clipPath id="75d75e67e1"><rect x="0" width="64" y="0" height="44"/></clipPath><clipPath id="e5df82bf12"><rect x="0" width="315" y="0" height="397"/></clipPath></defs><g clip-path="url(#864cd2432c)"><g transform="matrix(1, 0, 0, 1, 40, 0)"><g clip-path="url(#e5df82bf12)"><g transform="matrix(1, 0, 0, 1, 1, 0)"><g clip-path="url(#9e91a8b430)"><g fill="#20B2AA" fill-opacity="1"><g transform="translate(0.873977, 194.870819)"><g><path d="M 137.910156 0 L 137.910156 -174.546875 L 6.804688 -174.546875 L 6.804688 0 L 50.503906 0 L 50.503906 -48.675781 L 94.207031 -48.675781 L 94.207031 0 Z M 94.207031 -88.449219 L 50.503906 -88.449219 L 50.503906 -134.507812 L 94.207031 -134.507812 Z M 94.207031 -88.449219 "/></g></g></g></g></g><g clip-path="url(#9a4060e8fa)"><g transform="matrix(1, 0, 0, 1, 146, 116)"><g clip-path="url(#f5a1301079)"><g fill="#20B2AA" fill-opacity="1"><g transform="translate(1.206642, 267.950498)"><g><path d="M 137.910156 0 L 137.910156 -174.546875 L 6.804688 -174.546875 L 6.804688 0 Z M 94.207031 -39.777344 L 50.503906 -39.777344 L 50.503906 -134.507812 L 94.207031 -134.507812 Z M 94.207031 -39.777344 "/></g></g></g></g></g></g><g transform="matrix(1, 0, 0, 1, 148, 0)"><g clip-path="url(#45fb35c46f)"><g fill="#20B2AA" fill-opacity="1"><g transform="translate(0.26582, 194.870819)"><g><path d="M 137.386719 0 L 137.386719 -39.777344 L 50.503906 -39.777344 L 50.503906 -174.546875 L 6.804688 -174.546875 L 6.804688 0 Z M 137.386719 0 "/></g></g></g></g></g><g clip-path="url(#cd05768fb1)"><g transform="matrix(1, 0, 0, 1, -0.000000000000007105, 116)"><g clip-path="url(#f5e8ebd13e)"><g fill="#20B2AA" fill-opacity="1"><g transform="translate(1.876102, 267.950498)"><g><path d="M 137.910156 0 L 137.910156 -174.546875 L 94.207031 -174.546875 L 94.207031 -107.03125 L 50.503906 -107.03125 L 50.503906 -174.546875 L 6.804688 -174.546875 L 6.804688 0 L 50.503906 0 L 50.503906 -68.5625 L 94.207031 -68.5625 L 94.207031 0 Z M 137.910156 0 "/></g></g></g></g></g></g><g clip-path="url(#22bb000506)"><g transform="matrix(1, 0, 0, 1, 242, 20)"><g clip-path="url(#7703948ec8)"><g clip-path="url(#cb13c63ddb)"><path fill="#20B2AA" d="M 43.164062 120.25 L 0.375 120.25 L 0.375 0.414062 L 43.164062 0.414062 Z M 43.164062 120.25 " fill-opacity="1" fill-rule="nonzero"/></g></g></g></g><g clip-path="url(#0f7bc66451)"><g transform="matrix(1, 0, 0, 1, 213, 20)"><g clip-path="url(#75d75e67e1)"><g clip-path="url(#90aa4af11e)"><path fill="#20B2AA" d="M 0.839844 43.222656 L 0.839844 0.4375 L 63.683594 0.4375 L 63.683594 43.222656 Z M 0.839844 43.222656 " fill-opacity="1" fill-rule="nonzero"/></g></g></g></g></g></g></g></svg>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="w-full lg:w-1/3">
            <div id="scoring-panel" class="flex-1 flex flex-col gap-3 lg:gap-4 p-4 lg:p-6 glass-card rounded-2xl justify-between">
                <div class="flex justify-center items-center gap-3">
                    <button id="rules-btn" class="flex-1 py-2 px-4 themed-button text-sm font-semibold" style="color: var(--accent); background: var(--accent-light);">How to Play</button>
                    <button id="new-game-btn" class="flex-1 py-2 px-4 themed-button text-white font-semibold rounded-xl text-sm" style="background: var(--accent-gradient);">New Game</button>
                </div>

                <div class="relative w-full h-2.5 progress-bar-container">
                    <div id="progress-bar-fill" class="h-full rounded-full progress-bar-fill transition-all duration-300" style="width: 0%;"></div>
                </div>
                
                <div id="controls-area" class="controls-area"></div>
                
                <div class="grid grid-cols-2 gap-2 lg:gap-3 text-center">
                    <div class="glass-card rounded-xl px-3 py-2">
                        <h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: #4A5568;">Total Score</h3>
                        <p id="total-score" class="text-2xl font-bold transition-all duration-300" style="color: var(--accent);">0</p>
                    </div>
                    <div class="glass-card rounded-xl px-3 py-2">
                        <h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: #4A5568;">High Score</h3>
                        <p id="high-score" class="text-2xl font-bold" style="color: #FFD700;">0</p>
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-2 lg:gap-3 text-center">
                    <div class="glass-card rounded-xl px-3 py-2"><h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: #4A5568;">Rows</h3><p id="rows-total-score" class="text-lg font-bold">0</p></div>
                    <div class="glass-card rounded-xl px-3 py-2"><h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: #4A5568;">Columns</h3><p id="cols-total-score" class="text-lg font-bold">0</p></div>
                    <div class="glass-card rounded-xl px-3 py-2"><h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: #4A5568;">Twinning</h3><p id="cross-total-score" class="text-lg font-bold" style="color: #FFD700;">0</p></div>
                    <div class="glass-card rounded-xl px-3 py-2"><h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: #4A5568;">Grid Bonus</h3><p id="bonus-grid-score" class="text-lg font-bold" style="color: #FFD700;">0</p></div>
                </div>
                
                <div class="glass-card rounded-xl px-3 py-2">
                    <div class="text-center"><h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: #4A5568;">Bomb Squad Charge</h3><p id="empty-block-penalty" class="text-lg font-bold" style="color: var(--accent);">0</p></div>
                </div>
            </div>
        </div>
    </main>
    
    <div id="rules-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-lg themed-modal p-6 transform scale-95 -translate-y-4">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-3xl font-bold" style="font-family: 'Pacifico', cursive; color: var(--accent);">How to Play</h2>
                <button id="close-rules-btn" class="w-10 h-10 rounded-full text-xl flex items-center justify-center font-bold">×</button>
            </div>
            <div class="space-y-4 text-gray-700 text-sm max-h-[70vh] overflow-y-auto pr-2">
                <h3 class="font-bold text-lg" style="color: var(--accent);">The Objective</h3>
                <p>Get the highest score by placing Allohas on the grid to create sequences of 3 or more identical Allohas in a line (rows or columns).</p>
                
                <h3 class="font-bold text-lg" style="color: var(--accent);">Gameplay</h3>
                <ul class="list-disc list-inside space-y-1">
                    <li>Choose your starting Alloha to place in the top-left corner.</li>
                    <li>Click "Roll Dice" to get two new Allohas.</li>
                    <li>Place both Allohas in any two empty, adjacent (not diagonal) squares.</li>
                    <li>Continue for up to 24 turns until the grid fills or no valid moves remain.</li>
                </ul>

                <h3 class="font-bold text-lg" style="color: var(--accent);">Game End</h3>
                <p>The game ends when:</p>
                <ul class="list-disc list-inside space-y-1">
                    <li>All 24 turns are completed (grid nearly full).</li>
                    <li>No valid adjacent empty squares remain for placement.</li>
                </ul>

                <h3 class="font-bold text-lg" style="color: var(--accent);">ALLOHA Powers</h3>
                <p>Use one of three powerful, single-use abilities per game:</p>
                <ul class="list-disc list-inside space-y-1">
                    <li><b>Past Lives:</b> Undoes your last completed move.</li>
                    <li><b>Bomb Bae:</b> Click to activate, then click a stuck block (💣) to fill it with a random Alloha.</li>
                    <li><b>No Return:</b> Click to activate, then click any Alloha on the grid to swap it for a different one.</li>
                </ul>

                <h3 class="font-bold text-lg" style="color: var(--accent);">Special Blocks</h3>
                <ul class="list-disc list-inside space-y-1">
                    <li><b>Wild Card (💎):</b> Appears once between turns 15-22. Acts as any Alloha and can complete any sequence.</li>
                    <li><b>Cursed Block (☠️):</b> Appears once between turns 5-12. An immovable obstacle that cannot be removed by Bomb Bae or swapped with No Return.</li>
                </ul>

                <h3 class="font-bold text-lg" style="color: var(--accent);">Scoring System</h3>
                <h4 class="font-semibold text-gray-800">Line Scoring:</h4>
                <ul class="list-disc list-inside space-y-1">
                    <li><b>3 in a line:</b> 3 points</li>
                    <li><b>4 in a line:</b> 8 points</li>
                    <li><b>5 in a line:</b> 10 points</li>
                    <li><b>6 in a line:</b> 14 points</li>
                    <li><b>7 in a line:</b> 20 points</li>
                </ul>

                <h4 class="font-semibold text-gray-800 mt-2">Bonus Scoring:</h4>
                <ul class="list-disc list-inside space-y-1">
                    <li><b>Highlighted Area Bonus:</b> Scores on the highlighted area in the game board (the center 4th row or 4th column) are doubled.</li>
                    <li>
                        <p class="font-bold">Grid Bonus: The Power of Squares</p>
                        <p class="mt-1">You earn bonus points for forming solid square grids (2x2, 3x3, etc.) of the same Alloha. The score is the size of the grid squared (a 2x2 grid earns 4 points, a 3x3 grid earns 9, and so on).</p>
                        <p class="mt-1"><b>The Wild Card's Role:</b> The Wild Card (💎) is extremely valuable for creating grids. It can substitute for <b>any</b> Alloha to complete a square. For example, this arrangement counts as a 2x2 grid of Shells and earns 4 bonus points:</p>
                        <div class="my-2 p-2 rounded-md bg-gray-100 text-center font-mono text-lg">
                            <div>🐚 💎</div>
                            <div>🐚 🐚</div>
                        </div>
                        <p class="mt-1"><b>Overlapping Grids:</b> The game rewards complex patterns! A large grid can also contain smaller scoring grids within it. For example, a perfect 3x3 grid will not only earn 9 points for itself, but also points for the four 2x2 grids it contains, leading to a massive score boost!</p>
                    </li>
                </ul>

                <h4 class="font-semibold text-gray-800 mt-2">Penalties:</h4>
                <ul class="list-disc list-inside space-y-1">
                    <li><b>Bomb Squad Charge:</b> Empty squares with no adjacent empty squares become stuck blocks (💣), each giving a -1 penalty.</li>
                    <li><b>Dead Lines:</b> A row or column that can no longer form a 3-symbol sequence gets a -5 penalty.</li>
                    <li><b>Dead Highlighted Area:</b> A dead line on the highlighted center row or column gets a -10 penalty instead.</li>
                </ul>

                <h3 class="font-bold text-lg" style="color: var(--accent);">Strategy Tip</h3>
                <p>Focus on the center row and column early—their doubled scoring can dramatically boost your final score!</p>
            </div>
        </div>
    </div>
    
    <div id="game-over-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-md text-center themed-modal p-8 transform scale-95 -translate-y-4 relative">
            <button id="close-game-over-btn" class="absolute top-4 right-4 w-10 h-10 rounded-full text-xl flex items-center justify-center font-bold">×</button>
            <h2 class="text-4xl font-bold mb-2" style="color: var(--accent); font-family: 'Pacifico', cursive;">Game Over!</h2>
            <p id="game-over-reason" class="text-lg mt-2 mb-4" style="color: var(--accent);"></p>
            <p id="final-score-modal" class="text-7xl font-bold my-4" style="color: var(--accent);">0</p>
            <div id="score-breakdown" class="mb-6 p-4 glass-card rounded-xl text-xs">
                <div class="grid grid-cols-2 gap-2">
                    <div class="text-left">Rows: <span id="final-rows-score" class="float-right font-bold">0</span></div>
                    <div class="text-left">Columns: <span id="final-cols-score" class="float-right font-bold">0</span></div>
                    <div class="text-left">Twinning: <span id="final-cross-score" class="float-right font-bold">0</span></div>
                    <div class="text-left">Bonus Grids: <span id="final-bonus-score" class="float-right font-bold">0</span></div>
                    <div class="text-left col-span-2 border-t pt-2 mt-2">Bomb Squad Charge: <span id="final-penalty-score" class="float-right font-bold">0</span></div>
                </div>
            </div>
            <p>High score: <span id="high-score-modal" class="font-bold" style="color: #FFD700;">0</span></p>
            <button id="play-again-btn" class="w-full mt-6 themed-button text-white font-bold py-3 px-4 rounded-xl text-xl" style="background: var(--accent-gradient);">Play Again</button>
        </div>
    </div>
    
    <div id="exchange-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-sm text-center themed-modal p-6 transform scale-95 -translate-y-4">
            <h2 class="text-xl font-bold mb-4" style="color: var(--accent);">Choose a new Aqua Pet</h2>
            <div id="exchange-options" class="grid grid-cols-3 gap-4"></div>
        </div>
    </div>

    <script>
        // =================================================================================
        // GAME CONSTANTS
        // =================================================================================
        const GRID_SIZE = 7;
        const MAX_TURNS = 24;
        const MIN_SEQUENCE_LENGTH = 3;
        const CROSS_AXIS_INDEX = 3; // 4th row/col is index 3
        const LINE_DEATH_PENALTY = -5;
        const CROSS_DEATH_PENALTY = -10;
        const CURSED_BLOCK_MIN_TURN = 5;
        const CURSED_BLOCK_TURN_RANGE = 8;
        const WILD_CARD_MIN_TURN = 15;
        const WILD_CARD_TURN_RANGE = 8;

        const AQUA_SYMBOLS = { 'Shell': '🐚', 'Jellyfish': '🪼', 'Octopus': '🐙', 'Pufferfish': '🐡', 'Crab': '🦀', 'Whale': '🐋' };
        const SPECIAL_SYMBOLS = { 'WILD': '💎', 'CURSED': '☠️' };
        const SYMBOLS = Object.values(AQUA_SYMBOLS);
        const SYMBOL_COLORS = { '🐚': 'text-[#D2B48C]', '🪼': 'text-[#87CEEB]', '🐙': 'text-[#9370DB]', '🐡': 'text-[#FFD700]', '🦀': 'text-[#DC143C]', '🐋': 'text-[#4169E1]', '💎': 'text-yellow-400' };
        const SCORING_RULES = { 7: 20, 6: 14, 5: 10, 4: 8, 3: 3 };

        class GameState {
            constructor() { this.states = { PRE_GAME: 'PRE_GAME', AWAITING_ROLL: 'AWAITING_ROLL', ANIMATING_ROLL: 'ANIMATING_ROLL', AWAITING_PLACEMENT: 'AWAITING_PLACEMENT', SUPERPOWER_ACTIVE: 'SUPERPOWER_ACTIVE', PROCESSING_TURN: 'PROCESSING_TURN', GAME_OVER: 'GAME_OVER' }; this.currentState = this.states.PRE_GAME; this.validTransitions = { [this.states.PRE_GAME]: [this.states.AWAITING_ROLL], [this.states.AWAITING_ROLL]: [this.states.ANIMATING_ROLL, this.states.PRE_GAME, this.states.SUPERPOWER_ACTIVE, this.states.AWAITING_PLACEMENT], [this.states.ANIMATING_ROLL]: [this.states.AWAITING_PLACEMENT], [this.states.AWAITING_PLACEMENT]: [this.states.PROCESSING_TURN, this.states.AWAITING_ROLL, this.states.SUPERPOWER_ACTIVE], [this.states.SUPERPOWER_ACTIVE]: [this.states.AWAITING_ROLL, this.states.AWAITING_PLACEMENT, this.states.PROCESSING_TURN], [this.states.PROCESSING_TURN]: [this.states.AWAITING_ROLL, this.states.GAME_OVER], [this.states.GAME_OVER]: [this.states.PRE_GAME] }; }
            setState(newState) { if (!this.validTransitions[this.currentState]?.includes(newState)) { console.warn(`Invalid state transition from ${this.currentState} to ${newState}`); return false; } this.currentState = newState; return true; }
            is(state) { return this.currentState === state; }
        }

        class Game {
            constructor() {
                this.gameStateManager = new GameState();
                this.highScore = 0;
                this.gridCells = [];
                this.audio = { unlocked: false, context: null, sounds: new Map() };
                this.state = {};
                this.DOMElements = this.getDOMElements();
                this.init();
                this.createAmbientBubbles();
                this.setupEventListeners();
            }
            
            getDOMElements() {
                const elements = {};
                const elementIds = [
                    'game-board', 'controls-area', 'row-scores-display', 'col-scores-display', 'total-score', 
                    'high-score', 'rows-total-score', 'cols-total-score', 'cross-total-score', 'bonus-grid-score', 
                    'empty-block-penalty', 'rules-btn', 'rules-modal', 'close-rules-btn', 
                    'game-over-modal', 'game-over-reason', 'close-game-over-btn', 'final-score-modal', 
                    'high-score-modal', 'play-again-btn', 'score-breakdown', 'final-rows-score', 
                    'final-cols-score', 'final-cross-score', 'final-bonus-score', 'final-penalty-score', 
                    'exchange-modal', 'exchange-options', 'progress-bar-fill',
                    'new-game-btn', 'game-board-container', 'scoring-panel', 'bubbles-bg', 
                    'effects-container'
                ];
                elementIds.forEach(id => { elements[id] = document.getElementById(id); });
                return elements;
            }

            init() {
                this.gameStateManager.setState('PRE_GAME');
                this.state = {
                    gridData: Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null)),
                    currentRoll: [],
                    firstPlacementCell: null,
                    turnCount: 0,
                    stuckBlocks: new Set(),
                    hasSuperpowerBeenUsed: false,
                    activeSuperpower: null,
                    lastGameState: null,
                    cellToExchange: null,
                    currentTotalScore: 0,
                    cursedBlockTurn: Math.floor(Math.random() * CURSED_BLOCK_TURN_RANGE) + CURSED_BLOCK_MIN_TURN,
                    wildcardTurn: Math.floor(Math.random() * WILD_CARD_TURN_RANGE) + WILD_CARD_MIN_TURN,
                    highlightedCells: new Set(),
                };
                if (this.state.wildcardTurn === this.state.cursedBlockTurn) this.state.wildcardTurn++;

                this.highScore = parseInt(localStorage.getItem('allohaHighScore')) || 0;
                
                this.audioInit();
                this.DOMElements['high-score'].textContent = this.highScore;
                ['game-over-modal', 'exchange-modal', 'rules-modal'].forEach(id => this.DOMElements[id].classList.remove('is-open'));
                this.DOMElements['empty-block-penalty'].textContent = '0';
                this.clearValidMoveHighlights();
                this.renderGrid(); this.renderScorePlaceholders(); this.renderControls(); this.updateAllScores();
                this.updateProgressBar();
                this.syncPanelHeights();
            }

            audioInit() { this.audioCreateContext(); this.audioCreateSounds(); }
            audioCreateContext() { try { this.audio.context = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) {} }
            audioCreateSounds() { if (!this.audio.context) return; const s = { 'pop': [1200,.1,.05], 'roll': [220,.2,.2], 'hover': [660,.05,.1], 'invalid': [150,.3,.2], 'power-activate': [880,.15,.2], 'power-use': [1047,.2,.3], 'combo-3': [[523,659],.15], 'combo-4': [[523,659,784],.2], 'combo-5': [[523,659,784,880],.25], 'chime': [1047, .15, .2], 'thud': [100, .3, .1] }; for (const k in s) { if (Array.isArray(s[k][0])) this.audio.sounds.set(k, ()=>this.audioPlaySequence(...s[k])); else this.audio.sounds.set(k, ()=>this.audioPlayTone(...s[k])); } }
            audioPlayTone(freq, vol, dur) { if (!this.audio.unlocked || !this.audio.context) return; try { const o = this.audio.context.createOscillator(), g = this.audio.context.createGain(); o.connect(g); g.connect(this.audio.context.destination); o.frequency.setValueAtTime(freq, this.audio.context.currentTime); g.gain.setValueAtTime(0, this.audio.context.currentTime); g.gain.linearRampToValueAtTime(vol*.1, this.audio.context.currentTime+.01); g.gain.exponentialRampToValueAtTime(.001, this.audio.context.currentTime+dur); o.start(); o.stop(this.audio.context.currentTime+dur); } catch (e) {} }
            audioPlaySequence(freqs, dur) { freqs.forEach((f, i) => setTimeout(()=>this.audioPlayTone(f,.1,dur/freqs.length), i*(dur*1000/freqs.length))); }
            audioUnlock() { if (this.audio.unlocked) return; document.getElementById('audio-unlocker').play().finally(() => { this.audio.unlocked = true; }); }
            audioPlay(soundName) { this.audio.sounds.get(soundName)?.(); }

            createAmbientBubbles() {
                const bubbleContainer = this.DOMElements['bubbles-bg'];
                if (!bubbleContainer) return;
                bubbleContainer.innerHTML = '';
                for (let i = 0; i < 20; i++) {
                    const bubble = document.createElement('span');
                    bubble.className = 'bubble';
                    const size = Math.random() * 20 + 5 + 'px';
                    bubble.style.width = size;
                    bubble.style.height = size;
                    bubble.style.left = Math.random() * 100 + '%';
                    bubble.style.animationDuration = Math.random() * 8 + 7 + 's';
                    bubble.style.animationDelay = Math.random() * 5 + 's';
                    bubbleContainer.appendChild(bubble);
                }
            }
            
            calculateLineScore(line, type, lineIndex) {
                let totalScore = 0;
                const usedIndices = Array(GRID_SIZE).fill(false);
                const wildSymbol = SPECIAL_SYMBOLS.WILD;

                for (let len = GRID_SIZE; len >= MIN_SEQUENCE_LENGTH; len--) {
                    for (let i = 0; i <= GRID_SIZE - len; i++) {
                        const slice = line.slice(i, i + len);
                        
                        let alreadyUsed = false;
                        for (let k = 0; k < len; k++) {
                            if (slice[k] !== wildSymbol && usedIndices[i + k]) {
                                alreadyUsed = true;
                                break;
                            }
                        }
                        if (alreadyUsed) {
                            continue;
                        }

                        if (this.isValidSequence(slice)) {
                            totalScore += SCORING_RULES[len];
                            
                            for (let k = 0; k < len; k++) {
                                if (slice[k] !== wildSymbol) {
                                    usedIndices[i + k] = true;
                                }
                            }
                        }
                    }
                }
                
                if (totalScore === 0) {
                    if (this.isLineDead(line, type, lineIndex)) { return { score: LINE_DEATH_PENALTY }; }
                }
                
                return { score: totalScore };
            }
            
            isValidSequence(slice) {
                if (!slice[0]) return false;
                if (slice.every(s => s === SPECIAL_SYMBOLS.WILD)) return true;
                const regularSymbols = slice.filter(s => s !== SPECIAL_SYMBOLS.WILD);
                if (regularSymbols.length === 0) return true;
                if (new Set(regularSymbols).size === 1) return true;
                return false;
            }
            
            isLineDead(line, type, lineIndex) {
                for (let i = 0; i <= line.length - MIN_SEQUENCE_LENGTH; i++) {
                    const window = line.slice(i, i + MIN_SEQUENCE_LENGTH);
                    let winnable = true;
                    if (window.includes(SPECIAL_SYMBOLS.CURSED)) { winnable = false; continue; }
                    for (let j = 0; j < MIN_SEQUENCE_LENGTH; j++) {
                        let r, c;
                        if (type === 'row') { r = lineIndex; c = i + j; } else { r = i + j; c = lineIndex; }
                        if (this.state.stuckBlocks.has(`${r},${c}`)) { winnable = false; break; }
                    }
                    if (!winnable) continue;
                    const nonNullSymbols = window.filter(cell => cell !== null);
                    if (nonNullSymbols.length > 0) {
                        const regularSymbols = nonNullSymbols.filter(s => s !== SPECIAL_SYMBOLS.WILD);
                        if (regularSymbols.length > 0 && new Set(regularSymbols).size <= 1) { winnable = true; } 
                        else if (regularSymbols.length === 0) { winnable = true; } 
                        else { winnable = false; }
                    }
                    if (winnable) return false;
                }
                return true;
            }

            calculateBonusGrids(gridData) {
                let points = 0;
                for (let size = GRID_SIZE; size >= 2; size--) {
                    for (let r = 0; r <= GRID_SIZE - size; r++) {
                        for (let c = 0; c <= GRID_SIZE - size; c++) {
                            const firstSymbol = gridData[r][c];
                            if (!firstSymbol || firstSymbol === SPECIAL_SYMBOLS.CURSED) continue;
                            let targetSymbol = firstSymbol;
                            if (targetSymbol === SPECIAL_SYMBOLS.WILD) {
                                let foundSymbol = false;
                                for (let i = r; i < r + size; i++) {
                                    for (let j = c; j < c + size; j++) {
                                        const current = gridData[i][j];
                                        if (current && current !== SPECIAL_SYMBOLS.WILD && current !== SPECIAL_SYMBOLS.CURSED) {
                                            targetSymbol = current;
                                            foundSymbol = true;
                                            break;
                                        }
                                    }
                                    if (foundSymbol) break;
                                }
                            }
                            let isGrid = true;
                            for (let i = r; i < r + size; i++) {
                                for (let j = c; j < c + size; j++) {
                                    const currentSymbol = gridData[i][j];
                                    if (!currentSymbol || currentSymbol === SPECIAL_SYMBOLS.CURSED) { isGrid = false; break; }
                                    if (targetSymbol === SPECIAL_SYMBOLS.WILD) {
                                        if (currentSymbol !== SPECIAL_SYMBOLS.WILD) { isGrid = false; break; }
                                    } else {
                                        if (currentSymbol !== targetSymbol && currentSymbol !== SPECIAL_SYMBOLS.WILD) { isGrid = false; break; }
                                    }
                                }
                                if (!isGrid) break;
                            }
                            if (isGrid) { points += size * size; }
                        }
                    }
                }
                return points;
            }

            createCellElement(r, c) { const cell = document.createElement('div'); cell.dataset.row = r; cell.dataset.col = c; cell.className = this.getCellClasses(r, c); return cell; }
            getCellClasses(r, c) { let classes = 'grid-cell bg-[#E0F2F1]'; if (r === CROSS_AXIS_INDEX || c === CROSS_AXIS_INDEX) classes += ' cross-cell'; if (this.state.stuckBlocks.has(`${r},${c}`)) classes += ' stuck-cell'; return classes; }
            updateCell(cell, r, c) { const symbol = this.state.gridData[r][c]; cell.className = this.getCellClasses(r, c); if (symbol) { cell.textContent = symbol; if(SYMBOL_COLORS[symbol]) cell.classList.add(SYMBOL_COLORS[symbol]); cell.classList.add('pop-in'); } else if (this.state.stuckBlocks.has(`${r},${c}`)) { cell.textContent = '💣'; } else { cell.textContent = ''; } }
            addCellEventListeners(cell) { cell.addEventListener('click', this.handleCellClick.bind(this)); cell.addEventListener('mouseenter', () => { if (this.gameStateManager.is('AWAITING_PLACEMENT') || this.state.activeSuperpower) this.audioPlay('hover'); }); }

            syncPanelHeights() { setTimeout(() => { if (window.innerWidth < 1024) { this.DOMElements['scoring-panel'].style.height = 'auto'; return; } const boardHeight = this.DOMElements['game-board-container']?.getBoundingClientRect().height; if (boardHeight && this.DOMElements['scoring-panel']) { this.DOMElements['scoring-panel'].style.height = `${boardHeight}px`; } }, 50); }
            updateProgressBar() { if (!this.DOMElements['progress-bar-fill']) return; const percentage = (this.state.turnCount / MAX_TURNS) * 100; this.DOMElements['progress-bar-fill'].style.width = `${percentage}%`; }

            renderGrid() {
                const fragment = document.createDocumentFragment(); this.DOMElements['game-board'].innerHTML = ''; this.gridCells = [];
                for (let r = 0; r < GRID_SIZE; r++) {
                    const row = [];
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const cell = this.createCellElement(r, c); this.updateCell(cell, r, c); this.addCellEventListeners(cell);
                        fragment.appendChild(cell); row.push(cell);
                    }
                    this.gridCells.push(row);
                }
                this.DOMElements['game-board'].appendChild(fragment);
            }

            updateFullGrid() { for (let r = 0; r < GRID_SIZE; r++) for (let c = 0; c < GRID_SIZE; c++) this.updateGridCell(r, c); }
            updateGridCell(r, c) { if (this.gridCells[r]?.[c]) this.updateCell(this.gridCells[r][c], r, c); }

            renderScorePlaceholders() {
                this.DOMElements['row-scores-display'].innerHTML = ''; this.DOMElements['col-scores-display'].innerHTML = '';
                for (let i = 0; i < GRID_SIZE; i++) {
                    const rowScore = document.createElement('div'); rowScore.id = `row-score-${i}`; rowScore.className = 'grid-cell bg-[#E0F2F1] text-gray-400 text-lg lg:text-2xl'; rowScore.textContent = '0'; this.DOMElements['row-scores-display'].appendChild(rowScore);
                    const colScore = document.createElement('div'); colScore.id = `col-score-${i}`; colScore.className = 'grid-cell bg-[#E0F2F1] text-gray-400 text-lg lg:text-2xl'; colScore.textContent = '0'; this.DOMElements['col-scores-display'].appendChild(colScore);
                }
            }

            renderControls() {
                this.DOMElements['controls-area'].innerHTML = '';
                if (this.gameStateManager.is('PRE_GAME')) { this.renderPreGameControls(); } 
                else { this.renderGameControls(); this.setupSuperpowerEventListeners(); this.updateSuperpowerButtonsUI(); }
                this.syncPanelHeights();
            }

            renderPreGameControls() {
                const container = document.createElement('div'); container.className = 'w-full flex flex-col items-center';
                container.innerHTML = `<h2 class="text-base lg:text-lg font-semibold text-center mb-4 uppercase tracking-wider" style="color: var(--accent);">CHOOSE YOUR ALLOHA</h2>`;
                const selector = document.createElement('div'); selector.className = 'grid grid-cols-3 gap-2 lg:gap-4';
                SYMBOLS.forEach((symbol) => {
                    const btn = document.createElement('button');
                    btn.className = `symbol-selector-btn aspect-square rounded-xl text-4xl lg:text-5xl hover:bg-teal-100 ${SYMBOL_COLORS[symbol]} flex items-center justify-center`;
                    btn.textContent = symbol;
                    btn.onclick = () => this.handleSymbolSelect(symbol);
                    btn.onmouseenter = () => this.audioPlay('hover');
                    selector.appendChild(btn);
                });
                container.appendChild(selector);
                this.DOMElements['controls-area'].appendChild(container);
            }

            renderGameControls() {
                const wrapper = document.createElement('div'); wrapper.className = 'w-full flex flex-col justify-center gap-3 lg:gap-4';
                wrapper.innerHTML = `<div class="flex justify-center items-center gap-2 lg:gap-4"><button id="roll-dice-btn" class="w-14 h-14 lg:w-16 lg:h-16 text-4xl lg:text-5xl flex items-center justify-center transition-transform hover:scale-110 active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed" style="color: var(--accent);">🎲</button><div id="dice-1" class="w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card shadow-lg flex items-center justify-center text-3xl lg:text-4xl">?</div><div id="dice-2" class="w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card shadow-lg flex items-center justify-center text-3xl lg:text-4xl">?</div></div><div id="alloha-power-panel" class="glass-card rounded-xl px-3 py-4 text-center"><h2 class="text-sm font-semibold uppercase tracking-wider mb-3 flex items-center justify-center gap-2" style="color: #4A5568;"><span style="font-size: 16px;">🪄</span>ALLOHA Powers</h2><div class="grid grid-cols-3 gap-2 text-xs"><button id="past-lives-btn" class="superpower-btn"><div>Past</div><div>Lives</div></button><button id="bomb-bae-btn" class="superpower-btn"><div>Bomb</div><div>Bae</div></button><button id="no-return-btn" class="superpower-btn"><div>No</div><div>Return</div></button></div></div>`;
                wrapper.querySelector('#roll-dice-btn').onclick = this.handleRollDice.bind(this);
                this.DOMElements['controls-area'].appendChild(wrapper);
                this.updateControlsState();
            }

            updateControlsState() {
                if (this.gameStateManager.is('PRE_GAME')) return;
                const rollBtn = document.getElementById('roll-dice-btn');
                if (rollBtn) rollBtn.disabled = !this.gameStateManager.is('AWAITING_ROLL');
                const dice1 = document.getElementById('dice-1'), dice2 = document.getElementById('dice-2');
                if (!dice1 || !dice2) return;
                if (this.gameStateManager.is('AWAITING_PLACEMENT') && this.state.currentRoll.length === 2) {
                    dice1.textContent = this.state.currentRoll[0]; dice1.className = `w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card-prominent shadow-lg flex items-center justify-center text-3xl lg:text-4xl ${SYMBOL_COLORS[this.state.currentRoll[0]] || ''}`;
                    dice2.textContent = this.state.currentRoll[1]; dice2.className = `w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card-prominent shadow-lg flex items-center justify-center text-3xl lg:text-4xl ${SYMBOL_COLORS[this.state.currentRoll[1]] || ''}`;
                } else {
                    dice1.textContent = '?'; dice1.className = 'w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card shadow-lg flex items-center justify-center text-3xl lg:text-4xl';
                    dice2.textContent = '?'; dice2.className = 'w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card shadow-lg flex items-center justify-center text-3xl lg:text-4xl';
                }
            }

            handleSymbolSelect(symbol) { if (!this.gameStateManager.is('PRE_GAME')) return; this.audioUnlock(); this.audioPlay('pop'); this.state.gridData[0][0] = symbol; this.gameStateManager.setState('AWAITING_ROLL'); this.updateGridCell(0, 0); this.renderControls(); }

            handleRollDice() {
                if (!this.gameStateManager.is('AWAITING_ROLL') || this.gameStateManager.is('GAME_OVER')) return;
                const nextTurn = this.state.turnCount + 1; let tempRoll;
                if (nextTurn === this.state.cursedBlockTurn) { this.audioPlay('thud'); tempRoll = [SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)], SPECIAL_SYMBOLS.CURSED]; } 
                else if (nextTurn === this.state.wildcardTurn) { this.audioPlay('chime'); tempRoll = [SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)], SPECIAL_SYMBOLS.WILD]; } 
                else { this.audioPlay('roll'); tempRoll = [SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)], SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)]]; }
                this.state.currentRoll = tempRoll.sort(() => Math.random() - 0.5);
                this.gameStateManager.setState('ANIMATING_ROLL'); this.updateControlsState();
                const d1 = document.getElementById('dice-1'), d2 = document.getElementById('dice-2');
                d1.classList.add('dice-tumble'); d2.classList.add('dice-tumble');
                setTimeout(() => {
                    d1.classList.remove('dice-tumble'); d2.classList.remove('dice-tumble');
                    this.saveStateForUndo(); this.gameStateManager.setState('AWAITING_PLACEMENT'); this.updateControlsState();
                }, 600);
            }

            // --- MODIFIED: Main click handler for new touch logic ---
            handleCellClick(e) {
                const cell = e.target.closest('[data-row]'); if (!cell) return;
                const r = parseInt(cell.dataset.row), c = parseInt(cell.dataset.col);

                if (this.state.activeSuperpower) { this.handleSuperpowerCellClick(r, c, cell); return; }
                if (!this.gameStateManager.is('AWAITING_PLACEMENT')) return;

                if (this.state.firstPlacementCell) {
                    this.handleSecondPlacement(r, c, cell);
                } else {
                    this.handleFirstPlacement(r, c);
                }
            }
            
            // --- NEW/MODIFIED: Placement logic with highlighting ---
            handleFirstPlacement(r, c) {
                if (this.state.gridData[r][c]) return; // Cell is not empty

                this.state.gridData[r][c] = this.state.currentRoll[0];
                this.state.firstPlacementCell = { r, c };
                this.updateGridCell(r, c);
                this.updateSuperpowerButtonsUI();
                this.highlightValidMoves(r, c);
            }

            handleSecondPlacement(r, c, cell) {
                const { r: pR, c: pC } = this.state.firstPlacementCell;

                // Case 1: Tapping the first cell again to cancel
                if (pR === r && pC === c) {
                    this.state.gridData[r][c] = null;
                    this.state.firstPlacementCell = null;
                    this.updateGridCell(r, c);
                    this.updateSuperpowerButtonsUI();
                    this.clearValidMoveHighlights();
                    return;
                }

                // Case 2: Tapping a valid, highlighted cell
                if (this.state.highlightedCells.has(`${r},${c}`)) {
                    this.completeMove(r, c);
                } 
                // Case 3: Tapping an invalid cell
                else {
                    cell.classList.add('shake-animation');
                    setTimeout(() => cell.classList.remove('shake-animation'), 400);
                    this.audioPlay('invalid');
                }
            }

            // --- NEW: Highlight Functions ---
            highlightValidMoves(r, c) {
                this.clearValidMoveHighlights();
                const neighbors = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                neighbors.forEach(([dr, dc]) => {
                    const nr = r + dr;
                    const nc = c + dc;
                    if (nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE && !this.state.gridData[nr][nc]) {
                        this.state.highlightedCells.add(`${nr},${nc}`);
                        this.gridCells[nr]?.[nc]?.classList.add('valid-move-highlight');
                    }
                });
            }

            clearValidMoveHighlights() {
                if (this.state.highlightedCells.size > 0) {
                    this.state.highlightedCells.forEach(coord => {
                        const [r, c] = coord.split(',').map(Number);
                        this.gridCells[r]?.[c]?.classList.remove('valid-move-highlight');
                    });
                    this.state.highlightedCells.clear();
                }
            }


            saveStateForUndo() { this.state.lastGameState = { gridData: JSON.parse(JSON.stringify(this.state.gridData)), turnCount: this.state.turnCount, stuckBlocks: new Set(this.state.stuckBlocks), currentRoll: [...this.state.currentRoll] }; }
            
            completeMove(r, c) {
                this.clearValidMoveHighlights(); // Clear highlights on successful move
                this.gameStateManager.setState('PROCESSING_TURN');
                this.state.gridData[r][c] = this.state.currentRoll[1];
                this.state.firstPlacementCell = null;
                this.state.turnCount++;
                this.updateGridCell(r, c);
                this.audioPlay('pop');
                setTimeout(this.processTurnEnd.bind(this), 300);
            }
            
            processTurnEnd() {
                if (this.gameStateManager.is('GAME_OVER')) return;
                this.detectStuckBlocks(); this.updateAllScores(); this.updateProgressBar();
                if (this.state.turnCount >= MAX_TURNS) { this.endGame("Grid is full!"); return; }
                if (!this.hasValidMoves()) { this.endGame("No valid moves!"); return; }
                this.gameStateManager.setState('AWAITING_ROLL'); this.renderControls();
            }

            endGame(reason = "") {
                if (this.gameStateManager.is('GAME_OVER')) return;
                this.gameStateManager.setState('GAME_OVER'); this.updateAllScores();
                const finalScore = this.calculateTotalScore();
                if (finalScore > this.highScore) { this.highScore = finalScore; localStorage.setItem('allohaHighScore', this.highScore); }
                this.DOMElements['game-over-reason'].textContent = reason;
                this.DOMElements['final-score-modal'].textContent = finalScore;
                this.DOMElements['high-score-modal'].textContent = this.highScore;
                this.DOMElements['final-rows-score'].textContent = this.DOMElements['rows-total-score'].textContent;
                this.DOMElements['final-cols-score'].textContent = this.DOMElements['cols-total-score'].textContent;
                this.DOMElements['final-cross-score'].textContent = this.DOMElements['cross-total-score'].textContent;
                this.DOMElements['final-bonus-score'].textContent = this.DOMElements['bonus-grid-score'].textContent;
                this.DOMElements['final-penalty-score'].textContent = this.DOMElements['empty-block-penalty'].textContent;
                setTimeout(() => this.DOMElements['game-over-modal'].classList.add('is-open'), 500);
            }

            hasValidMoves() { for (let r = 0; r < GRID_SIZE; r++) for (let c = 0; c < GRID_SIZE; c++) if (!this.state.gridData[r][c]) { const n = [[-1, 0], [1, 0], [0, -1], [0, 1]]; for (const [dr, dc] of n) { const nr = r + dr, nc = c + dc; if (nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE && !this.state.gridData[nr][nc]) return true; } } return false; }
            detectStuckBlocks() { this.state.stuckBlocks.clear(); for (let r = 0; r < GRID_SIZE; r++) for (let c = 0; c < GRID_SIZE; c++) if (!this.state.gridData[r][c]) { const n = [[-1, 0], [1, 0], [0, -1], [0, 1]]; if (n.every(([dr, dc]) => { const nr = r + dr, nc = c + dc; return nr < 0 || nr >= GRID_SIZE || nc < 0 || nc >= GRID_SIZE || this.state.gridData[nr][nc] })) this.state.stuckBlocks.add(`${r},${c}`); } this.updateFullGrid(); this.DOMElements['empty-block-penalty'].textContent = -this.state.stuckBlocks.size; }
            
            updateAllScores() {
                const oldScore = this.state.currentTotalScore;
                const rS = this.calculateRowScores(), cS = this.calculateColumnScores(), crS = this.calculateCrossScore(), bS = this.calculateBonusGrids(this.state.gridData);
                const newScore = rS.total + cS.total + crS + bS - this.state.stuckBlocks.size;
                const scoreDiff = newScore - oldScore;
                if (scoreDiff > 0) { this.triggerScoreBubbles(Math.min(10, Math.ceil(scoreDiff / 2))); }
                this.state.currentTotalScore = newScore;
                this.updateScoreDisplays(rS.total, cS.total, crS, bS, this.state.stuckBlocks.size);
                this.updateIndividualScores(rS.individual, cS.individual);
            }
            calculateTotalScore() { return this.state.currentTotalScore; }
            calculateRowScores() { let t = 0, ind = []; for (let i = 0; i < GRID_SIZE; i++) { const { score: s } = this.calculateLineScore(this.state.gridData[i], 'row', i); ind.push(s); t += s; } return { total: t, individual: ind }; }
            calculateColumnScores() { let t = 0, ind = []; for (let i = 0; i < GRID_SIZE; i++) { const col = this.state.gridData.map(row => row[i]); const { score: s } = this.calculateLineScore(col, 'col', i); ind.push(s); t += s; } return { total: t, individual: ind }; }
            
            calculateCrossScore() {
                let bonusScore = 0;
                const crossRow = this.state.gridData[CROSS_AXIS_INDEX];
                const crossCol = this.state.gridData.map(row => row[CROSS_AXIS_INDEX]);
                const rowResult = this.calculateLineScore(crossRow, 'row', CROSS_AXIS_INDEX);
                const colResult = this.calculateLineScore(crossCol, 'col', CROSS_AXIS_INDEX);
                if (rowResult.score > 0) { bonusScore += rowResult.score; } 
                else if (rowResult.score === LINE_DEATH_PENALTY) { bonusScore += CROSS_DEATH_PENALTY - LINE_DEATH_PENALTY; }
                if (colResult.score > 0) { bonusScore += colResult.score; } 
                else if (colResult.score === LINE_DEATH_PENALTY) { bonusScore += CROSS_DEATH_PENALTY - LINE_DEATH_PENALTY; }
                return bonusScore;
            }

            updateScoreDisplays(r, c, cross, b, s) { const t = r + c + cross + b - s; this.animateScoreUpdate(this.DOMElements['total-score'], t); this.animateScoreUpdate(this.DOMElements['rows-total-score'], r); this.animateScoreUpdate(this.DOMElements['cols-total-score'], c); this.animateScoreUpdate(this.DOMElements['cross-total-score'], cross); this.animateScoreUpdate(this.DOMElements['bonus-grid-score'], b); }
            
            animateScoreUpdate(el, val) {
                const startVal = parseInt(el.textContent) || 0;
                if (startVal === val) return;
                el.classList.add('score-update');
                const duration = 500; const stepTime = 20; const totalSteps = duration / stepTime;
                const increment = (val - startVal) / totalSteps;
                let currentVal = startVal; let step = 0;
                const timer = setInterval(() => {
                    step++;
                    if (step >= totalSteps) {
                        clearInterval(timer);
                        el.textContent = val;
                        setTimeout(() => el.classList.remove('score-update'), 100);
                        return;
                    }
                    currentVal += increment;
                    el.textContent = Math.round(currentVal);
                }, stepTime);
            }

            updateIndividualScores(rS, cS) { rS.forEach((s, i) => this.updateScoreElement(`row-score-${i}`, s)); cS.forEach((s, i) => this.updateScoreElement(`col-score-${i}`, s)); }
            updateScoreElement(id, score) { const el = document.getElementById(id); if (el && parseInt(el.textContent) !== score) { el.textContent = score; el.classList.toggle('text-red-500', score < 0); if (score !== 0) { el.classList.add('score-flash'); setTimeout(() => el.classList.remove('score-flash'), 600); } } }

            updateSuperpowerButtonsUI() {
                const isUsed = this.state.hasSuperpowerBeenUsed; const isMidMove = this.state.firstPlacementCell !== null; const isPowerActive = this.state.activeSuperpower !== null;
                const pastLivesBtn = document.getElementById('past-lives-btn'); const bombBaeBtn = document.getElementById('bomb-bae-btn'); const noReturnBtn = document.getElementById('no-return-btn');
                if (pastLivesBtn) pastLivesBtn.disabled = isUsed || !this.state.lastGameState || isMidMove || isPowerActive;
                if (bombBaeBtn) bombBaeBtn.disabled = isUsed || this.state.stuckBlocks.size === 0 || isMidMove || isPowerActive;
                if (noReturnBtn) noReturnBtn.disabled = isUsed || isMidMove || isPowerActive;
                [pastLivesBtn, bombBaeBtn, noReturnBtn].forEach(btn => btn?.classList.remove('superpower-btn--active'));
                if (this.state.activeSuperpower) { const id = { 'bombBae': 'bomb-bae-btn', 'noReturn': 'no-return-btn' }[this.state.activeSuperpower]; const activeBtn = document.getElementById(id); if (activeBtn) activeBtn.classList.add('superpower-btn--active'); }
                document.body.classList.toggle('cursor-target', this.state.activeSuperpower === 'bombBae');
            }

            handleSuperpowerCellClick(r, c, cell) {
                if (this.state.gridData[r][c] === SPECIAL_SYMBOLS.CURSED) { this.audioPlay('invalid'); cell.classList.add('shake-animation'); setTimeout(() => cell.classList.remove('shake-animation'), 400); return; }
                if (this.state.activeSuperpower === 'bombBae' && this.state.stuckBlocks.has(`${r},${c}`)) { this.state.stuckBlocks.delete(`${r},${c}`); this.state.gridData[r][c] = SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)]; this.consumeSuperpower(); this.gameStateManager.setState('AWAITING_ROLL'); this.renderControls(); } 
                else if (this.state.activeSuperpower === 'noReturn' && this.state.gridData[r][c]) { this.showSymbolSelectorForExchange(r, c); } 
                else { this.audioPlay('invalid'); }
            }
            
            showSymbolSelectorForExchange(r, c) {
                 this.state.cellToExchange = {r, c}; this.DOMElements['exchange-options'].innerHTML = '';
                 SYMBOLS.filter(s => s !== this.state.gridData[r][c]).forEach(symbol => {
                    const btn = document.createElement('button'); btn.className = 'symbol-selector-btn w-20 h-20 text-4xl rounded-lg hover:bg-teal-100 flex items-center justify-center'; btn.textContent = symbol;
                    btn.onclick = () => this.handleSymbolExchange(symbol); this.DOMElements['exchange-options'].appendChild(btn);
                 });
                 this.DOMElements['exchange-modal'].classList.add('is-open');
            }
            
            handleSymbolExchange(newSymbol) {
                if (!this.state.cellToExchange) return;
                const {r, c} = this.state.cellToExchange; this.state.gridData[r][c] = newSymbol;
                this.DOMElements['exchange-modal'].classList.remove('is-open'); this.state.cellToExchange = null;
                this.consumeSuperpower(); this.gameStateManager.setState('AWAITING_ROLL'); this.renderControls();
            }

            consumeSuperpower() { this.audioPlay('power-use'); this.state.hasSuperpowerBeenUsed = true; this.state.activeSuperpower = null; this.updateFullGrid(); this.updateAllScores(); this.updateSuperpowerButtonsUI(); }

            setupSuperpowerEventListeners() {
                const pastLivesBtn = document.getElementById('past-lives-btn');
                if (pastLivesBtn) {
                    pastLivesBtn.addEventListener('click', () => {
                        if (pastLivesBtn.disabled) return;
                        this.audioPlay('power-activate');
                        this.state.gridData = this.state.lastGameState.gridData; this.state.turnCount = this.state.lastGameState.turnCount; this.state.stuckBlocks = this.state.lastGameState.stuckBlocks; this.state.currentRoll = this.state.lastGameState.currentRoll; this.state.lastGameState = null; 
                        this.state.hasSuperpowerBeenUsed = true; this.state.activeSuperpower = null; this.audioPlay('power-use');
                        this.updateFullGrid(); this.updateAllScores(); this.updateSuperpowerButtonsUI();
                        this.updateProgressBar(); this.gameStateManager.setState('AWAITING_PLACEMENT'); this.updateControlsState();
                    });
                }
                const bombBaeBtn = document.getElementById('bomb-bae-btn');
                if (bombBaeBtn) {
                    bombBaeBtn.addEventListener('click', () => { if (bombBaeBtn.disabled) return; this.cancelPlacementAndActivateSuperpower('bombBae'); });
                }
                const noReturnBtn = document.getElementById('no-return-btn');
                if (noReturnBtn) {
                    noReturnBtn.addEventListener('click', () => { if (noReturnBtn.disabled) return; this.cancelPlacementAndActivateSuperpower('noReturn'); });
                }
            }
            
            // --- NEW: Helper to cancel a move if a superpower is activated ---
            cancelPlacementAndActivateSuperpower(superpowerName) {
                if (this.state.firstPlacementCell) {
                    const { r, c } = this.state.firstPlacementCell;
                    this.state.gridData[r][c] = null;
                    this.state.firstPlacementCell = null;
                    this.updateGridCell(r, c);
                    this.clearValidMoveHighlights();
                }
                this.state.activeSuperpower = superpowerName;
                this.gameStateManager.setState('SUPERPOWER_ACTIVE');
                this.audioPlay('power-activate');
                this.updateSuperpowerButtonsUI();
            }

            setupEventListeners() {
                this.DOMElements['new-game-btn'].addEventListener('click', this.init.bind(this));
                this.DOMElements['rules-btn'].addEventListener('click', () => this.DOMElements['rules-modal'].classList.add('is-open'));
                this.DOMElements['close-rules-btn'].addEventListener('click', () => this.DOMElements['rules-modal'].classList.remove('is-open'));
                this.DOMElements['close-game-over-btn'].addEventListener('click', () => this.DOMElements['game-over-modal'].classList.remove('is-open'));
                this.DOMElements['play-again-btn'].addEventListener('click', () => { this.DOMElements['game-over-modal'].classList.remove('is-open'); setTimeout(this.init.bind(this), 200); });
                window.addEventListener('resize', this.syncPanelHeights.bind(this));
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        if (this.state.activeSuperpower) { this.state.activeSuperpower = null; this.updateSuperpowerButtonsUI(); this.gameStateManager.setState(this.state.firstPlacementCell ? 'AWAITING_PLACEMENT' : 'AWAITING_ROLL'); } 
                        else { ['rules-modal', 'game-over-modal', 'exchange-modal'].forEach(id => this.DOMElements[id].classList.remove('is-open')); }
                    }
                    if ((e.key === ' ' || e.key === 'Enter') && this.gameStateManager.is('AWAITING_ROLL')) { e.preventDefault(); this.handleRollDice(); }
                });
            };
        }

        document.addEventListener('DOMContentLoaded', () => {
            new Game();
        });
    </script>
</body>
</html>
